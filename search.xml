<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[PHP中浮点数位数截取性能大比拼]]></title>
      <url>https://helei112g.github.io/2017/02/16/PHP%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BD%8D%E6%95%B0%E6%88%AA%E5%8F%96%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
      <content type="html"><![CDATA[<p>本文没什么好说的，点进来看吧… …<br><a id="more"></a></p>
<p>最近工作中，在处理电商用户下单模块的时候，之前遗留系统保留的是三位小数。这里带来了一个问题：<br>如果用户的订单价格是：6.666元，那么在向支付宝或者微信发起支付时，第三方只会保留两位数，也就是用户实际付款：6.66元。</p>
<p>那么问题来了，支付成功第三方回调系统接口，在接口中的逻辑需要比对支付的金额，会发现 6.666≠6.66，然后后面的逻辑无法运行，处理失败。</p>
<p>这里引申出来的一个问题是：我们对浮点数位数保留时，该使用何种方式？</p>
<p>php中提供了很多种处理浮点数位数的方式。</p>
<ul>
<li>number_format — 以千位分隔符方式格式化一个数字</li>
<li>round — 对浮点数进行四舍五入 (通过传入第三个参数，可以控制舍、入的方式)</li>
<li>sprintf — Return a formatted string</li>
<li>bcadd — 2个任意精度数字的加法计算</li>
</ul>
<p>还有一种方式就是字符串截取，比如以前三位小数，现在只要两位，就把最后一位截去。</p>
<p>但是，这种方式千万别用，非常无耻，万一某个数据查询出来是：9999元，你把最后一位搞掉变成：999元，自己赔公司损失吧。</p>
<p>说完处理的方式，不得不提一下性能问题。这里由于 <code>round</code> 函数如果数字后面全是0的话。不能正确处理小数位数，这里就先不提.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$data = array_fill(0, 1, range(1, 100000, 1.1))[0];</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    number_format(10000, 2, &apos;.&apos;, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;number_format time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    bcadd($num, 0, 2);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;bcadd time: &#123;$need&#125;&quot; . PHP_EOL);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">foreach ($data as $num) &#123;</span><br><span class="line">    sprintf(&apos;.2%f&apos;, $num);</span><br><span class="line">&#125;</span><br><span class="line">$end = microtime(true);</span><br><span class="line">$need = $end - $start;</span><br><span class="line">print(&quot;sprintf time: &#123;$need&#125;&quot; . PHP_EOL);</span><br></pre></td></tr></table></figure>
<p>上面的代码运行，会得到以下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number_format time: 0.086385011672974</span><br><span class="line">bcadd time: 0.098035097122192</span><br><span class="line">sprintf time: 0.069508075714111</span><br></pre></td></tr></table></figure></p>
<p>所以通过对比，推荐使用 <code>sprintf</code> 来处理浮点数位数的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swoole入门指南：PHP7安装Swoole详细教程（一）]]></title>
      <url>https://helei112g.github.io/2017/02/08/Swoole%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9APHP7%E5%AE%89%E8%A3%85Swoole%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>本教程一步步深入swoole，通过demo讲解它的学习与使用方法。<br><a id="more"></a></p>
<p>好久未更新了，不是懒呃，是太忙啦！终于偷得浮生几日闲。<br>这一段时间准备为大家带来swoole的入门教程，感受一下php的nodeJs强悍之处。</p>
<p>所有的示例代码均放在了github上：<a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">learn-swoole</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>这里不在使用apache做为web server。该用nginx + php-fpm，性能更强大，配置更方便。并且为了跟上php的步伐，也使用了比较新的php版本</p>
<ul>
<li>[x] centos7</li>
<li>[x] php7.0.12</li>
<li>[x] nginx/1.10.2</li>
<li>[x] php-fpm</li>
</ul>
<h1 id="下载-swoole"><a href="#下载-swoole" class="headerlink" title="下载 swoole"></a>下载 swoole</h1><p>首先下载swoole的源码包，这个操作很简单，没有太多说的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/swoole/swoole-src/archive/v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">解压: tar -zxvf v2.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">cd swoole-src-2.0.6/</span><br></pre></td></tr></table></figure></p>
<h1 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h1><p>使用phpize来生成php编译配置</p>
<p><em>./configure</em> 来做编译配置检测</p>
<p>make进行编译，make install进行安装</p>
<p>命令执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# phpize</span><br><span class="line">[root@php7 swoole-src-2.0.6]# ./configure</span><br><span class="line">[root@php7 swoole-src-2.0.6]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>make install后，如果正确，会出现以下内容<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# make install</span><br><span class="line">Installing shared extensions:     /usr/lib64/php/modules/</span><br></pre></td></tr></table></figure></p>
<p>这表示，在 <code>/usr/lib64/php/modules/</code> 目录中，成功生成了 <code>swoole.so</code> 文件</p>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>要能够使用该模块，还需要在 <code>php.ini</code> 文件中添加该模块。</p>
<p>这里需要注意，php7的模块配置文件均单独分开了。<br>在 <code>php.ini</code> 中可找到如下内容</p>
<blockquote>
<p>;;;;<br>; Note: packaged extension modules are now loaded via the .ini files<br>; found in the directory /etc/php.d; these are loaded by default.<br>;;;;</p>
</blockquote>
<p>因此，如果你的php安装时，如果未特殊设置，可以在<code>/etc/php.d</code> 目录中，找到添加模块的配置文件。</p>
<p>进入到  <em>cd /etc/php.d</em> 目录，完成相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# vim swoole.ini</span><br><span class="line"></span><br><span class="line">; Enable swoole extension module</span><br><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure>
<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1><p>新增php模块后，需要重新启动服务，才会生效，如果有时候restart后依然无效，请先关闭，再重新启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart nginx</span><br><span class="line">[root@php7 swoole-src-2.0.6]# systemctl restart php-fpm</span><br></pre></td></tr></table></figure>
<p>通过php -m或phpinfo()来查看是否成功加载了swoole</p>
<p><img src="https://helei112g.github.io/images/swoole-phpinfo.png" alt="image"></p>
<h1 id="swoole-代码的自动提示"><a href="#swoole-代码的自动提示" class="headerlink" title="swoole 代码的自动提示"></a>swoole 代码的自动提示</h1><p>安装好扩展后，就是使用的问题。由于没有代码的提示，有时候很不方便，github上有人已经提供了swoole代码提示的 ide-helper 。具体设置办法如下：</p>
<p>这里以： phpStorme 为例，download 代码到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:eaglewu/swoole-ide-helper.git ide-helper</span><br></pre></td></tr></table></figure></p>
<p>按照图片内容设置<br><img src="https://helei112g.github.io/images/swoole-setting.png" alt="image"></p>
<p>经过以上步骤，可以在 phpStorme 中使用swoole了。并且提供代码提示。</p>
<h1 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h1><p>所有的测试代码均放在 <a href="https://github.com/helei112g/learn-swoole" target="_blank" rel="external">这里</a></p>
<p>请将该代码 <code>clone</code> 到本地，方便观察效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:helei112g/learn-swoole.git</span><br></pre></td></tr></table></figure></p>
<p>本节所提供的代码实例 <a href="https://github.com/helei112g/learn-swoole/blob/master/demo1-serv.php" target="_blank" rel="external">demo1-serv</a></p>
<p>进入到测试代码目录，</p>
<p>然后在服务端使用 <code>telnet</code> 进行测试</p>
<hr>
<ul>
<li>首先，运行服务端的监听程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php demo1-serv.php</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行这个命令后，服务器会显示： </p>
<blockquote>
<p><code>Client: Connect.</code> </p>
</blockquote>
<ul>
<li>另外开一个终端，使用 <code>telnet</code> 连接当前服务端监听的端口，并且输入一些文字，观察终端的变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# telnet 127.0.0.1 9999</span><br><span class="line">Hi!</span><br><span class="line">Server: Hi!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里只是进行简单的模拟回复。客户端发什么，服务器就回应什么消息。<br>退出telnet，观察服务器会显示什么<br>直接关闭窗口，或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php7 ~]# Ctrl+]</span><br><span class="line">[root@php7 ~]# telnet&gt; quit</span><br></pre></td></tr></table></figure>
<p>此时，会在服务侧看到：</p>
<blockquote>
<p>Client: Close.</p>
</blockquote>
<p>PS：如果测试环境没有安装 <code>telnet</code> ，请自行google安装。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列五：Vagrant使用中遇到的坑]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%94%EF%BC%9AVagrant%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>这篇文章是在windows上使用了vagrant半年后，突然切换到mac上来，遇到了各种坑，今天补了这篇文章。希望对你有帮助。</p>
<a id="more"></a>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>之前写了一系列的vagrant使用教程，当时写这个教程的时候实在windows的环境下。最近再mac上使用，遇到了一些麻烦。</p>
<p><a href="http://blog.csdn.net/hel12he/article/details/51069269" target="_blank" rel="external">原文章路径</a></p>
<p>今天最想说的一个问题就是权限的问题。</p>
<p>在windows中由于没有文件权限的概念，所有当我们共享目录后，共享目录默认就是777权限。<br>但是当我使用mac时，共享后的目录权限以及用户组都不正确了。无法正常使用。这样导致的一个直接问题就是：</p>
<blockquote>
<p>项目a运行在虚拟机中，需要向runtime目录写入日志或者临时文件之类的，总之就是需要读写权限。</p>
</blockquote>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>当时我直接ssh上vagrang后，给予777权限，无法写入，然后又在主机给予777权限，可以写入一个文件，但是下个文件又拿到权限写入。</p>
<p>后来由各种google与百度，看到说使用nfs的方式可以解决这个问题，但是各方给出的解决方案都很成旧，有的方法使用后甚至虚拟机都无法启动了。</p>
<p>没办法，老老实实上官网看nfs相关的配置吧。老实说官方给的文档真的是有点太简单抽象了，只能结合之前的一些东西结合起来使用。最终终于找到办法，这里将相关的配置贴出来，供大家参考。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">config.vm.define :php7 <span class="keyword">do</span> |p7|</span><br><span class="line">  p7.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"php6"</span>, <span class="string">"--memory"</span>, <span class="string">"512"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 域名解析慢</span></span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnshostresolver1"</span>, <span class="string">"on"</span>]</span><br><span class="line">        v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--natdnsproxy1"</span>, <span class="string">"on"</span>]</span><br><span class="line">  end</span><br><span class="line">  p7.vm.box = <span class="string">"CentOs7"</span></span><br><span class="line">  p7.vm.hostname = <span class="string">"php7"</span></span><br><span class="line">  p7.vm.network :private_network, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ssh 奇怪：第一次启动虚拟机无法获取ip</span></span><br><span class="line">  p7.ssh.username = <span class="string">"root"</span></span><br><span class="line">  p7.ssh.password = <span class="string">"vagrant"</span></span><br><span class="line">  p7.ssh.host = <span class="string">"192.168.33.11"</span></span><br><span class="line">  p7.ssh.port = <span class="number">22</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">## nfs文件权限问题  启动了好几次才正常，不知道原因</span></span><br><span class="line">  p7.vm.synced_folder <span class="string">"./www"</span>, <span class="string">"/data/wwwroot"</span>, type: <span class="string">"nfs"</span>, :nfs =&gt; &#123;</span><br><span class="line">    :linux_nfs_options =&gt; [<span class="string">"not_root_squash"</span>],</span><br><span class="line">    :map_uid =&gt; <span class="number">0</span>,</span><br><span class="line">    :map_gid =&gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这个配置是在一个 <code>Vagrantfile</code> 中配置多台机器的配置文档。其中遇到的一些奇怪问题，注释中都标明了。</p>
<ul>
<li>配置的ip地址，首次使用 <code>vagrant up php7</code> 后，无效，需要重新启动，虚拟机才能拿到这个ip。至今不懂为什么，麻烦知道的告诉我一下啊！</li>
<li>nfs配置信息全面解决了权限问题。你需要给出什么权限直接在 vagrang 虚拟机中进行设置。但是在挂载目录时，有时候配置的新机器会莫名其妙重新启动好几次才可以。我启动了三次。</li>
<li><p>另一个坑是，新机器安装后，需要配置dns解析。否则有的资源是无法下载的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">## 增加以下内容</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于配置了启动时使用 <code>root</code> 帐号，需要每次在mac上启动的时候输入机器密码，很麻烦，官方指导配置 <code>/etc/sudoers</code> 如下内容</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cmnd_Alias VAGRANT_EXPORTS_ADD = /usr/bin/tee -a /etc/exports</span><br><span class="line">Cmnd_Alias VAGRANT_NFSD = /sbin/nfsd restart</span><br><span class="line">Cmnd_Alias VAGRANT_EXPORTS_REMOVE = /usr/bin/sed -E -e /*/ d -ibak /etc/exports</span><br><span class="line">%admin ALL=(root) NOPASSWD: VAGRANT_EXPORTS_ADD, VAGRANT_NFSD, VAGRANT_EXPORTS_REMOVE</span><br></pre></td></tr></table></figure>
<p><em>该配置仅针对mac</em></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这类问题还是蛮常见，对于使用很久的用户，轻松解决了，但是对于大多数使用vagrant的新手，这个问题很头痛，可能直接导致放弃使用vagrant吧。为了不让你放弃，我必须写出来帮助大家渡过这道坑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列四：Vagrant搭建redis与redis的监控程序redis-stat]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E5%9B%9B%EF%BC%9AVagrant%E6%90%AD%E5%BB%BAredis%E4%B8%8Eredis%E7%9A%84%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8Fredis-stat/</url>
      <content type="html"><![CDATA[<p>redis经常会被用到<br><a id="more"></a></p>
<p><strong>重要提示，从3.2版本后，redis需要设置密码才能够被外部网络访问。</strong><br>所以如果你发现可以链接上redis，但是无法写入或者读取那么请检查是否使用了密码方式。</p>
<h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><p>哎，写到这儿，说一句，诅咒联通这网络，联通网络一上，打开vpn，照样不能访问外网，联baidu都一卡一卡的。</p>
<p>redis就不用yum来进行安装了。直接从官方下载来安装吧。(老实说，我也不知道yum里边有没有redis的最新版)</p>
<h2 id="下载redis"><a href="#下载redis" class="headerlink" title="下载redis"></a>下载redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>当然你也可以到<a href="http://redis.io/download" target="_blank" rel="external">redis官网</a> 下载最新的版本。当然个人建议，开发中还是使用稳定版本吧！<br><img src="http://img.blog.csdn.net/20160412233549976" alt="这里写图片描述"></p>
<h2 id="解压redis"><a href="#解压redis" class="headerlink" title="解压redis"></a>解压redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf redis-3.0.7.tar.gz</span><br></pre></td></tr></table></figure>
<p>这个命令什么意思，我就不多说了，如果不清楚的同学，建议平时还是多积累点linux的命令知识额。加薪升职的利器额。<br><img src="http://img.blog.csdn.net/20160412233743743" alt="这里写图片描述"></p>
<h2 id="编译安装redis"><a href="#编译安装redis" class="headerlink" title="编译安装redis"></a>编译安装redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd redis-3.0.7</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>进入到解压后的目录，然后执行编译，然后安装。</p>
<p><img src="http://img.blog.csdn.net/20160412233953683" alt="这里写图片描述"></p>
<p>OK，至此，我们的redis安装还没有完额，其实好玩儿的才刚刚开始呢。</p>
<h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>创建redis 配置文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir /etc/redis</span><br></pre></td></tr></table></figure></p>
<p>在/var/lib/redis 下创建有效的保存数据的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　mkdir -p /var/lib/redis/6379</span><br></pre></td></tr></table></figure></p>
<p>redis.conf 是 redis 的配置文件，然而你会看到我们会把这个文件的名字改为 6379.conf ，而这个数字就是 redis 监听的网络端口。如果你想要运行超过一个的 redis 实例，推荐用这样的名字。</p>
<p>复制示例的 redis.conf 到 /etc/redis/6379.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></p>
<p>修改的内容如下：</p>
<blockquote>
<p>设置 daemonize 为 no，systemd 需要它运行在前台，否则 redis 会突然挂掉。<br>daemonize yes</p>
<p>设置 pidfile 为 /var/run/redis_6379.pid。<br>pidfile /var/run/redis_6379.pid</p>
<p>如果不准备用默认端口，可以修改。<br>port 6379</p>
<p>设置日志级别。<br>loglevel debug</p>
<p>修改日志文件路径。<br>logfile /var/log/redis_6379.log</p>
<p>设置目录为 /var/lib/redis/6379<br>dir /var/lib/redis/6379</p>
</blockquote>
<p>redis配置文件，各项的详解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line">######################### 通用 #########################</span><br><span class="line"></span><br><span class="line"># 启动后台进程</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 后台进程的pid文件存储位置</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"># 默认监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 只接受以下绑定的IP请求</span><br><span class="line"># Examples:</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 设置unix监听，默认为空</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line">#客户端空闲多长时间，关闭链接，0表示不关闭</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line"># 如果是非零值，当失去链接时，会使用SO_KEEPALIVE发送TCP ACKs 到客户端。</span><br><span class="line"># 这个参数有两个作用:</span><br><span class="line"># 1.检测断点。</span><br><span class="line"># 2.从网络中间设备来看，就是保持链接</span><br><span class="line"># 在Linux上，设定的时间就是发送ACKs的周期。</span><br><span class="line"># 注意：达到双倍的设定时间才会关闭链接。在其他内核上，周期依赖于内核设置。</span><br><span class="line"># 一个比较合理的值为60s</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># 指定日志级别，以下记录信息依次递减</span><br><span class="line"># debug用于开发/测试</span><br><span class="line"># verbose没debug那么详细</span><br><span class="line"># notice适用于生产线</span><br><span class="line"># warning只记录非常重要的信息</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#日志文件名称，如果为stdout则输出到标准输出端，如果是以后台进程运行则不产生日志</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 要想启用系统日志记录器，设置一下选项为yes</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指明syslog身份</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指明syslog设备。必须是一个用户或者是local0 ~ local7之一</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line">#设置数据库数目，第一个数据库编号为：0</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">######################### 快照 #########################</span><br><span class="line"></span><br><span class="line"># 在什么条件下保存数据库到磁盘，条件可以有很多个，满足任何一个条件都会进行快照存储</span><br><span class="line"># 在900秒之内有一次key的变化</span><br><span class="line">save 900 1</span><br><span class="line"># 在300秒之内，有10个key的变化</span><br><span class="line">save 300 10</span><br><span class="line"># 在60秒之内有10000个key变化</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 当持久化失败的时候，是否继续提供服务</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 当写入磁盘时，是否使用LZF算法压缩数据，默认为yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否添加CRC64校验到每个文件末尾--花费时间保证安全</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># 磁盘上数据库的保存名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># Redis工作目录，以上数据库保存文件和AOF日志都会写入此目录</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">######################### 主从同步 #########################</span><br><span class="line"></span><br><span class="line"># 主从复制，当本机是slave时配置</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># 当主机需要密码验证时候配置</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当slave和master丢失链接，或正处于同步过程中。是否响应客户端请求</span><br><span class="line"># 设置为yes表示响应</span><br><span class="line"># 设置为no，直接返回&quot;SYNC with master in progress&quot;（正在和主服务器同步中）</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 设置slave是否为只读。</span><br><span class="line"># 注意：即使slave设置为只读，也不能令其暴露在不受信任的网络环境中</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 无硬盘复制功能</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 等待多个slave一起来请求之间的间隔时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 设置slave给master发送ping的时间间隔</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 设置数据传输I/O，主机数据、ping响应超时时间，默认60s</span><br><span class="line"># 这个时间一定要比repl-ping-slave-period大，否则会不断检测到超时</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否在SYNC后slave socket上禁用TCP_NODELAY？</span><br><span class="line"># 如果你设置为yes，Redis会使用少量TCP报文和少量带宽发送数据给slave。</span><br><span class="line"># 但是这样会在slave端出现延迟。如果使用Linux内核的默认设置，大概40毫秒。</span><br><span class="line"># 如果你设置为no，那么在slave端研究就会减少但是同步带宽要增加。</span><br><span class="line"># 默认我们是为低延迟优化的。</span><br><span class="line"># 但是如果流量特别大或者主从服务器相距比较远，设置为yes比较合理。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置复制的后台日志大小。</span><br><span class="line"># 复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。</span><br><span class="line"># 后台日志在至少有一个 slave 连接时，仅仅分配一次。</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。</span><br><span class="line"># 0 意味着从不释放后台日志</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># 设置slave优先级，默认为100</span><br><span class="line"># 当主服务器不能正确工作的时候，数字低的首先被提升为主服务器，但是0是禁用选择</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 如果少于 N 个 slave 连接，且延迟时间 &lt;=M 秒，则 master 可配置停止接受写操作。</span><br><span class="line"># 例如需要至少 3 个 slave 连接，且延迟 &lt;=10 秒的配置：</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"># 设置 0 为禁用</span><br><span class="line"># 默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10</span><br><span class="line"></span><br><span class="line">######################### 安全 #########################</span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line"># requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置客户端连接密码，因为Redis响应速度可以达到每秒100w次，所以密码要特别复杂</span><br><span class="line">requirepass 1413</span><br><span class="line"></span><br><span class="line"># 命令重新命名，或者禁用。</span><br><span class="line"># 重命名命令为空字符串可以禁用一些危险命令比如：FLUSHALL删除所有数据</span><br><span class="line"># 需要注意的是，写入AOF文件或传送给slave的命令别名也许会引起一些问题</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">######################### 限制 #########################</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># 设置最多链接客户端数量，默认为10000。</span><br><span class="line"># 实际可以接受的请求数目为设置值减去32，这32是Redis为内部文件描述符保留的</span><br><span class="line"># maxclients 10000</span><br><span class="line"># 设置最大使用内存数量，在把Redis当作LRU缓存时特别有用。</span><br><span class="line"># 设置的值要比系统能使用的值要小</span><br><span class="line"># 因为当启用删除算法时，slave输出缓存也要占用内存</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">#达到最大内存限制时，使用何种删除算法</span><br><span class="line"># volatile-lru  使用LRU算法移除带有过期标致的key</span><br><span class="line"># allkeys-lru -&gt; 使用LRU算法移除任何key</span><br><span class="line"># volatile-random -&gt; 随机移除一个带有过期标致的key</span><br><span class="line"># allkeys-random -&gt;  随机移除一个key</span><br><span class="line"># volatile-ttl -&gt; 移除最近要过期的key</span><br><span class="line"># noeviction -&gt; 不删除key，当有写请求时，返回错误</span><br><span class="line">#默认设置为volatile-lru</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU和最小TTL算法没有精确的实现</span><br><span class="line"># 为了节省内存只在一个样本范围内选择一个最近最少使用的key，可以设置这个样本大小</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">######################### AO模式 #########################</span><br><span class="line"></span><br><span class="line"># AOF和RDB持久化可以同时启用</span><br><span class="line"># Redis启动时候会读取AOF文件，AOF文件有更好的持久化保证</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF的保存名称，默认为appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 设置何时写入追加日志，又三种模式</span><br><span class="line"># no：表示由操作系统决定何时写入。性能最好，但可靠性最低</span><br><span class="line"># everysec：表示每秒执行一次写入。折中方案，推荐</span><br><span class="line"># always：表示每次都写入磁盘。性能最差，比上面的安全一些</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 当AOF同步策略设定为alway或everysec</span><br><span class="line"># 当后台存储进程（后台存储或者AOF日志后台写入）会产生很多磁盘开销</span><br><span class="line"># 某些Linux配置会使Redis因为fsync()调用产生阻塞很久</span><br><span class="line"># 现在还没有修复补丁，甚至使用不同线程进行fsync都会阻塞我们的同步write(2)调用。</span><br><span class="line"># 为了缓解这个问题，使用以下选项在一个BGSAVE或BGREWRITEAOF运行的时候</span><br><span class="line"># 可以阻止fsync()在主程序中被调用，</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># AOF自动重写（合并命令，减少日志大小）</span><br><span class="line"># 当AOF日志大小增加到一个特定比率，Redis调用BGREWRITEAOF自动重写日志文件</span><br><span class="line"># 原理：Redis 会记录上次重写后AOF文件的文件大小。</span><br><span class="line"># 如果刚启动，则记录启动时AOF大小</span><br><span class="line"># 这个基本大小会用来和当前大小比较。如果当前大小比特定比率大，就会触发重写。</span><br><span class="line"># 你也需要指定一个AOF需要被重写的最小值，这样会避免达到了比率。</span><br><span class="line"># 但是AOF文件还很小的情况下重写AOF文件。</span><br><span class="line"># 设置为0禁用自动重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#redis在启动时可以加载被截断的AOF文件，而不需要先执行 redis-check-aof 工具</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">######################### LUA脚本 #########################</span><br><span class="line"></span><br><span class="line"># Lua脚本的最大执行时间，单位毫秒</span><br><span class="line"># 超时后会报错，并且计入日志</span><br><span class="line"># 当一个脚本运行时间超过了最大执行时间</span><br><span class="line"># 只有SCRIPT KILL和 SHUTDOWN NOSAVE两个命令可以使用。</span><br><span class="line"># SCRIPT KILL用于停止没有调用写命令的脚本。</span><br><span class="line"># SHUTDOWN NOSAVE是唯一的一个，在脚本的写命令正在执行</span><br><span class="line"># 用户又不想等待脚本的正常结束的情况下，关闭服务器的方法。</span><br><span class="line"># 以下选项设置为0或负数就会取消脚本执行时间限制</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">####################### redis集群  ########################</span><br><span class="line"></span><br><span class="line"># 是否启用集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群配置文件</span><br><span class="line"># 集群配置变更后会自动写入改文件</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 节点互连超时的阀值 </span><br><span class="line"># 节点超时时间，超过该时间无法连接主要Master节点后，会停止接受查询服务 </span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 控制从节点FailOver相关的设置,设为0，从节点会一直尝试启动FailOver.</span><br><span class="line"># 设为正数，失联大于一定时间（factor*节点TimeOut），不再进行FailOver</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 最小从节点连接数</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认为Yes,丢失一定比例Key后（可能Node无法连接或者挂掉），集群停止接受写操作</span><br><span class="line"># 设置为No，集群丢失Key的情况下仍提供查询服务</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">######################### 慢查询 #########################</span><br><span class="line"></span><br><span class="line"># Redis慢查询日志记录超过设定时间的查询，且只记录执行命令的时间</span><br><span class="line"># 不记录I/O操作，比如：和客户端交互，发送回复等。</span><br><span class="line"># 时间单位为微妙，1000000微妙 = 1 秒</span><br><span class="line"># 设置为负数会禁用慢查询日志，设置为0会记录所有查询命令</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 日志长度没有限制，但是会消耗内存。超过日志长度后，最旧的记录会被移除</span><br><span class="line"># 使用SLOWLOG RESET命令可以回收内存</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">######################### 延迟监测 #########################</span><br><span class="line"></span><br><span class="line"># 系统只记录超过设定值的操作，单位是毫秒，0表示禁用该功能  </span><br><span class="line"># 可以通过命令“CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;” 直接设置而不需要重启redis  </span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">######################### 事件通知 #########################</span><br><span class="line">#  当事件发生时， Redis 可以通知 Pub/Sub 客户端。</span><br><span class="line">#  可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识：</span><br><span class="line"># K     Keyspace 事件，以 _keyspace@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># E     Keyevent 事件，以 _keysevent@&lt;db&gt;_ 的前缀方式发布</span><br><span class="line"># g     通用事件（不指定类型），像 DEL, EXPIRE, RENAME, …</span><br><span class="line"># $     String 命令</span><br><span class="line"># s     Set 命令</span><br><span class="line"># h     Hash 命令</span><br><span class="line"># z     有序集合命令</span><br><span class="line"># x     过期事件（每次 key 过期时生成）</span><br><span class="line"># e     清除事件（当 key 在内存被清除时生成）</span><br><span class="line"># A     g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件</span><br><span class="line"># notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span><br><span class="line">#  例子：启用 list 和通用事件：</span><br><span class="line"># notify-keyspace-events Elg</span><br><span class="line">#  默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。</span><br><span class="line">#  注意如果你不指定至少 K 或 E 之一，不会发送任何事件。</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">#notify-keyspace-events AKE</span><br><span class="line"></span><br><span class="line">######################### 高级设置 #########################</span><br><span class="line"></span><br><span class="line"># 当有少量条目的时候，哈希使用高效内存数据结构。最大的条目也不能超过设定的阈值。# “少量”定义如下：</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 和哈希编码一样，少量列表也以特殊方式编码节省内存。“少量”设定如下：</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 集合只在以下情况下使用特殊编码来节省内存</span><br><span class="line"># --&gt;集合全部由64位带符号10进制整数构成的字符串组成</span><br><span class="line"># 下面的选项设置这个特殊集合的大小。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># 当有序集合的长度和元素设定为以下数字时，又特殊编码节省内存</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HyperLogLog 稀疏表示字节限制</span><br><span class="line"># 这个限制包含了16个字节的头部，当一个HyperLogLog使用sparse representation</span><br><span class="line"># 超过了这个显示，它就会转换到dense representation上</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># 哈希刷新使用每100个CPU毫秒中的1毫秒来帮助刷新主哈希表（顶级键值映射表）。</span><br><span class="line">#  Redis哈希表使用延迟刷新机制，越多操作，越多刷新。</span><br><span class="line"># 如果服务器空闲，刷新操作就不会进行，更多内存会被哈希表占用</span><br><span class="line"># 默认每秒进行10次主字典刷新，释放内存。</span><br><span class="line"># 如果你有硬性延迟需求，偶尔2毫秒的延迟无法忍受的话。设置为no</span><br><span class="line"># 否则设置为yes</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端输出缓存限制强迫断开读取速度比较慢的客户端</span><br><span class="line"># 有三种类型的限制</span><br><span class="line"># normal -&gt; 正常</span><br><span class="line"># slave  -&gt; slave和 MONITOR</span><br><span class="line"># pubsub -&gt; 客户端至少订阅了一个频道或者模式</span><br><span class="line"># 客户端输出缓存限制语法如下（时间单位：秒）</span><br><span class="line"># client-output-buffer-limit &lt;类别&gt; &lt;强制限制&gt; &lt;软性限制&gt; &lt;软性时间&gt;</span><br><span class="line"># 达到强制限制缓存大小，立刻断开链接。</span><br><span class="line"># 达到软性限制，仍然会有软性时间大小的链接时间</span><br><span class="line"># 默认正常客户端无限制，只有请求后，异步客户端数据请求速度快于它能读取数据的速度</span><br><span class="line"># 订阅模式和主从客户端又默认限制，因为它们都接受推送。</span><br><span class="line"># 强制限制和软性限制都可以设置为0来禁用这个特性</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># 设置Redis后台任务执行频率，比如清除过期键任务。</span><br><span class="line"># 设置范围为1到500，默认为10.越大CPU消耗越大，延迟越小。</span><br><span class="line"># 建议不要超过100</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># 当子进程重写AOF文件，以下选项开启时，AOF文件会每产生32M数据同步一次。</span><br><span class="line"># 这有助于更快写入文件到磁盘避免延迟</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure></p>
<p>##　redis开机自启动<br>复制redis的自启动脚本到init.d中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp utils/redis_init_script /etc/init.d/redis_6379</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下哈，镜像还是前面用的CentOs7，所以有的命令稍微跟6不一样。建立一个redis的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$　vim /etc/systemd/system/redis_6379.service</span><br></pre></td></tr></table></figure></p>
<p>然后输入下面的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis on port 6379</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/init.d/redis_6379 start</span><br><span class="line">ExecStop=/etc/init.d/redis_6379 stop</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>注意上面文件的目录，就是刚刚复制的目录，如果有多个redis，这里需要注意。</p>
<h2 id="系统参数的调整"><a href="#系统参数的调整" class="headerlink" title="系统参数的调整"></a>系统参数的调整</h2><p>为了让redis正常运行，需要对某些系统参数进行调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 避免数据被截断</span><br><span class="line">$　sysctl -w vm.overcommit_memory=1</span><br><span class="line"></span><br><span class="line"># 修改 backlog 连接数的最大值超过 redis.conf 中的 tcp-backlog 值，即默认值511</span><br><span class="line">$ sysctl -w net.core.somaxconn=512</span><br><span class="line"></span><br><span class="line"># 取消对透明巨页内存（transparent huge pages）的支持，因为这会造成 redis 使用过程产生延时和内存访问问题。</span><br><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>然后将以上配置，写入相关文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p>
<p>输入内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory = 1</span><br><span class="line">net.core.somaxconn=512</span><br></pre></td></tr></table></figure></p>
<p>对于透明巨页内存支持，并没有直接 sysctl 命令可以控制，所以需要将下面的命令放到 /etc/rc.local 的结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>通过以上配置，可以来启动redis服务了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start redis_6379</span><br><span class="line"># 设置为开机启动</span><br><span class="line">$ systemctl enable redis_6379</span><br><span class="line"># 通过以下命令，查看redis的状态</span><br><span class="line">$ systemctl status redis_6379</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413105018714" alt="这里写图片描述"></p>
<p>然后使用客户端来进行测试一下redis服务是否正常，参见截图：<br><img src="http://img.blog.csdn.net/20160413105130090" alt="这里写图片描述"></p>
<h1 id="redis的监控redis-stat的安装"><a href="#redis的监控redis-stat的安装" class="headerlink" title="redis的监控redis-stat的安装"></a>redis的监控redis-stat的安装</h1><p>由于redis-stat是使用ruby开发的，在安装前，请确保你的环境已经有了ruby的环境，如果没有，请自行google、百度安装之，我就不写了哦。<br>由于ruby默认使用的镜像在国外，剩下的不说了，大家都懂得，然后万能的淘宝镜像，切换一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>证据如下：<br><img src="http://img.blog.csdn.net/20160413105728889" alt="这里写图片描述"></p>
<p>然后开始安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install redis-stat</span><br></pre></td></tr></table></figure></p>
<p>然后，一般来说，你会发现报错啦，报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing redis-stat:</span><br><span class="line">	ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    /usr/bin/ruby extconf.rb</span><br><span class="line">mkmf.rb can&apos;t find header files for ruby at /usr/share/include/ruby.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Gem files will remain installed in /usr/local/share/gems/gems/json-1.8.3 for inspection.</span><br><span class="line">Results logged to /usr/local/share/gems/gems/json-1.8.3/ext/json/ext/generator/gem_make.out</span><br></pre></td></tr></table></figure></p>
<p>哈哈，，我好机智，想到大家很多人会搜索这个错误信息，会不会因此被带到这里呢？就像试试认真写的博客，会有多少人看。<br>这个错呢，很简单，就是因为没有安装ruby-devel，所有通过yum给安装上吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install ruby-devel</span><br></pre></td></tr></table></figure></p>
<p>这个就不要截图了吧。没什么好看的。</p>
<p>安装完成后，再次执行 <code>gem install redis-stat</code><br><img src="http://img.blog.csdn.net/20160413110515627" alt="这里写图片描述"></p>
<p>然后，至此安装完成，看一看劳动成果吧。随便说一句，它对redis的效率影响，基本可以忽略不计，因此，可以放心的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-stat</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160413110608484" alt="这里写图片描述"></p>
<p>然后，他会自带一个web的版本。大家可以通过浏览器来访问，具体方式留给大家自己去查一查，搜一搜吧。</p>
<p>单机版的redis服务安装与监控，就全部搞定。so easy！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列三：Vagrant搭建的php7环境]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9AVagrant%E6%90%AD%E5%BB%BA%E7%9A%84php7%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>本文实战教你如何搭建自己的开发环境。希望大家通过本文实战后，可以根据自己的情况搭建任意想要的环境。<br><a id="more"></a></p>
<p>前面已经把vagrant的基础知识已经基本过了一遍 了，相信只要按着教程来，你已经搭建好了自己的基础环境。接下来说一说如何搭建php7的开发环境。</p>
<blockquote>
<p>申明一下，这里使用的box，就是前面演示的centos7<br>地址奉上：<br><a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>首先需要跟新一些ngin的相关源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">// 执行安装过程</span><br><span class="line">$ yum install nginx</span><br></pre></td></tr></table></figure></p>
<p>看到以下界面时，请稍等，如果需要输入的地方，请直接按 <code>y</code> 然后回车。<br><img src="http://img.blog.csdn.net/20160406225356057" alt="这里写图片描述"></p>
<h2 id="启动nginx并设置为开机启动"><a href="#启动nginx并设置为开机启动" class="headerlink" title="启动nginx并设置为开机启动"></a>启动nginx并设置为开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start nginx </span><br><span class="line">$ systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h1 id="安装epel与remi源"><a href="#安装epel与remi源" class="headerlink" title="安装epel与remi源"></a>安装epel与remi源</h1><p>安装epel，epel是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。安装时一定需要注意一下自己系统的版本额。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://mirrors.opencas.cn/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>2016-10-22日修改：</p>
<blockquote>
<p>最近发上面的源不能用了。请大家自己在这里找对应的版本<br><a href="http://dl.fedoraproject.org/pub/" target="_blank" rel="external">http://dl.fedoraproject.org/pub/</a><br>过不了墙的请用国内镜像<br><a href="http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm" target="_blank" rel="external">http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-8.noarch.rpm</a></p>
</blockquote>
<p>remi源种包含最新的php相关信息，如：php7、mysql等，因此为了便捷获取php7的最新信息，也需要安装一下这个源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure></p>
<h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><p>因为以前经常使用iptables，对centos7自带的firewalld防火墙不熟悉，因此我就将关闭centos7自带的firewalld，启用自己熟悉的iptables吧。</p>
<p>首先，关闭自带的firewalld防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service </span><br><span class="line">$ systemctl disable firewalld.service #防止开机启动</span><br></pre></td></tr></table></figure></p>
<h2 id="安装iptables"><a href="#安装iptables" class="headerlink" title="安装iptables"></a>安装iptables</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install iptables-services</span><br></pre></td></tr></table></figure>
<p>安装进程如下图所示<br><img src="http://img.blog.csdn.net/20160406225557402" alt="这里写图片描述"></p>
<p>启动iptables防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start iptables.service </span><br><span class="line">systemctl enable iptables.service #开机自动启动</span><br></pre></td></tr></table></figure></p>
<h2 id="编辑防火墙配置文件"><a href="#编辑防火墙配置文件" class="headerlink" title="编辑防火墙配置文件"></a>编辑防火墙配置文件</h2><p>为了我们在自己的主机上能够顺利访问，需要开启以下端口，<br>vim /etc/sysconfig/iptables<br>编辑防火墙，设置80(nginx) 3306(mysql/mariadb) 6379(redis)端口，外网可访问<br><img src="http://img.blog.csdn.net/20160406225918341" alt="这里写图片描述"></p>
<h1 id="PHP7-0的安装"><a href="#PHP7-0的安装" class="headerlink" title="PHP7.0的安装"></a>PHP7.0的安装</h1><p>查看remi源中可安装的php信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list --enablerepo=remi --enablerepo=remi-php70 | grep php70</span><br></pre></td></tr></table></figure></p>
<p>该列表会列出所有可以安装的php模块信息，从中安装自己需要的模块，下面安装模块，是我自己的一个模块选择情况。其中有一部分是必须的，有一部分是可选的。比如php-fpm就是必须的，如果你用的是nginx的话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install --enablerepo=remi --enablerepo=remi-php70 php php-opcache php-pecl-apcu php-devel php-mbstring php-mcrypt php-mysqlnd php-pecl-xdebug php-pdo php-pear php-fpm php-cli php-xml php-bcmath php-process php-gd php-common php-json php-imap php-pecl-redis php-pecl-memcached php-pecl-mongodb</span><br></pre></td></tr></table></figure></p>
<p>安装完成后,输入 <code>php -v</code> 可以查看当前安装的php版本信息。<br><img src="http://img.blog.csdn.net/20160406230204248" alt="这里写图片描述"></p>
<p>启动php-fpm，因为nginx需要通过它来解析php程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start php-fpm</span><br><span class="line">$ systemctl enable php-fpm #设置开机自启动</span><br></pre></td></tr></table></figure></p>
<h2 id="配置nginx可以访问php"><a href="#配置nginx可以访问php" class="headerlink" title="配置nginx可以访问php"></a>配置nginx可以访问php</h2><p>进入nginx的文件配置中心，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx/conf.d/</span><br><span class="line"># 复制默认的配置文件 </span><br><span class="line">$ cp default.conf php.conf</span><br></pre></td></tr></table></figure></p>
<p>首先先通过vim编辑default文件。将监听端口改为8080， 因为后面我们自己的php.conf会用到80端口。<br><img src="http://img.blog.csdn.net/20160406230633531" alt="这里写图片描述"></p>
<p>现在来编辑复制的php.conf文件，可以直接复制以下内容，至于配置的含义，后面再开一篇文章来单独讲解吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /vagrant/www;# 自己的项目目录，也就是php项目所在目录</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">	    # 请注意，一定要加index.php这项</span><br><span class="line">        index  index.php index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        # 注意此处变量的不同</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改完文件后，必须要重新启动nginx，才会使当前的配置生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl reload nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>在/vagrant/www下新建一个文件index.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br></pre></td></tr></table></figure>
<p>在浏览器中打开，访问对应的ip，可以看到输出的php信息<br><img src="http://img.blog.csdn.net/20160406233803608" alt="这里写图片描述"></p>
<p><em>注：如果在使用过程中，有新增加的php模块，需要重新启动php－fpm</em></p>
<p><code>systemctl reload php-fpm</code></p>
<h1 id="Mariadb的安装"><a href="#Mariadb的安装" class="headerlink" title="Mariadb的安装"></a>Mariadb的安装</h1><p>这里很多同学可能第一次听说mariadb，他呢是mysql的一个重要分子，或者可以理解为mysql的替代品，自从mysql被控制后，更新速度已经慢太多了。两者的用法基本没有区别，实际中有哪些坑，大家可以自己去踩一踩。哈哈，别说我不负责任。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">$ yum install mariadb-server</span><br><span class="line"># 启动服务</span><br><span class="line">$ systemctl start mariadb</span><br><span class="line"># 开机启动</span><br><span class="line">$ systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="MariaDB的安全配置"><a href="#MariaDB的安全配置" class="headerlink" title="MariaDB的安全配置"></a>MariaDB的安全配置</h2><p>MariaDB默认root密码为空，我们需要设置一下，执行脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></p>
<p>这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。</p>
<p>首先提示输入当前的root密码：</p>
<blockquote>
<p>Enter current password for root (enter for none):<br>初始root密码为空，我们直接敲回车进行下一步。</p>
<p>Set root password? [Y/n]<br>设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。</p>
<p>Remove anonymous users? [Y/n]<br>是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。</p>
<p>Disallow root login remotely? [Y/n]<br>是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。</p>
<p>Remove test database and access to it? [Y/n]<br>是否删除测试用的数据库和权限？ 建议按照默认设置，回车继续。</p>
<p>Reload privilege tables now? [Y/n]<br>是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。</p>
</blockquote>
<p>完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。<br><img src="http://img.blog.csdn.net/20160406232302024" alt="这里写图片描述"></p>
<p>最后我们将MariaDB设置为开机启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure></p>
<h2 id="让外网可以进行链接"><a href="#让外网可以进行链接" class="headerlink" title="让外网可以进行链接"></a>让外网可以进行链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<h1 id="安装composer"><a href="#安装composer" class="headerlink" title="安装composer"></a>安装composer</h1><p>composer的大名，我就不想介绍了，如果你是一个phper，没用过，我也就不怪你，毕竟但是他现在才刚过1.0版，但是如果听都没听过，请面壁去……</p>
<p>安装说明<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php -r “readfile(‘https:<span class="comment">//getcomposer.org/installer‘);” &gt; composer-setup.php</span></span><br><span class="line"></span><br><span class="line">$ php composer-setup.php</span><br><span class="line"></span><br><span class="line">$ php -r “unlink(‘composer-setup.php’);”</span><br></pre></td></tr></table></figure></p>
<p>上述 3 条命令的作用依次是：</p>
<blockquote>
<ol>
<li>下载安装脚本（composer-setup.php）到当前目录。 </li>
<li>执行安装过程。 </li>
<li>删除安装脚本 – composer-setup.php 。</li>
</ol>
</blockquote>
<h2 id="全局安装composer"><a href="#全局安装composer" class="headerlink" title="全局安装composer"></a>全局安装composer</h2><p>全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。</p>
<p>Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure>
<p>然后执行：<br><code>composer -v</code><br><img src="http://img.blog.csdn.net/20160406233243543" alt="这里写图片描述"><br>由于composer的包都在国外，这里设置一下composer的配置，让其每次运行时，都使用国内的包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https:<span class="comment">//packagist.phpcomposer.com</span></span><br></pre></td></tr></table></figure></p>
<p>查看composer的配置文件<br>vim /root/.composer/config.json<br><img src="http://img.blog.csdn.net/20160406233556529" alt="这里写图片描述"><br>看到以上内容，表示配置成功！</p>
<hr>
<p>至此，基本的php7环境搭建已经完成了。然后呢，下一次说一说用vagrant搭建redis吧。当然我不会仅仅只说redis的搭建额。到时候看啊吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列二：Vagrant的配置文件vagrantfile详解]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9AVagrant%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6vagrantfile%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>通过配置文件轻松的完成一台机器的配置，使用过vm然后再来使用这个，你就会惊叹怎会如此方便。</p>
<a id="more"></a>
<p>上一篇文章完整的讲叙了如何安装一个vagrant的环境。这里主要说一说vagrant的配置文件Vagrantfile。我在尝试各种技术的时候，常常苦恼于很多时候没有教程把相关的配置信息说明完整。所以在我的博客里，我一定会完整的把这块给补上。</p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>在我们的开发目录下有一个文件Vagrantfile，里面包含有大量的配置信息，主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant的一些基础配置。Vagrant是使用Ruby开发的，所以它的配置语法也是Ruby的，但是我们没有学过Ruby的人还是可以跟着它的注释知道怎么配置一些基本项的配置。</p>
<p><strong>box设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.box = <span class="string">"CentOs7"</span></span><br></pre></td></tr></table></figure></p>
<p>该名称是再使用 vagrant init 中后面跟的名字。</p>
<p><strong>hostname设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.hostname = <span class="string">"for_work"</span></span><br></pre></td></tr></table></figure></p>
<p>设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的。比如，我安装了php7 php56两台虚拟机，再启动时，我可以通过vagrant up php7来指定只启动哪一台。</p>
<p><strong>虚拟机网络设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network <span class="string">"private_network"</span>, ip: <span class="string">"192.168.33.10"</span></span><br><span class="line"><span class="comment">#config.vm.network "public_network"</span></span><br></pre></td></tr></table></figure></p>
<p>Vagrant有两种方式来进行网络连接，一种是host-only(主机模式)，意思是主机和虚拟机之间的网络互访，而不是虚拟机访问internet的技术，也就是只有你一個人自High，其他人访问不到你的虚拟机。另一种是Bridge(桥接模式)，该模式下的VM就像是局域网中的一台独立的主机，也就是说需要VM到你的路由器要IP，这样的话局域网里面其他机器就可以访问它了。我一般设置为host－only模式。<br>当然该模式，再指定ip的时候注意不要跟主机所在网段发生冲突。</p>
<p><strong>同步目录设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder  <span class="string">"/Users/helei/www"</span>, <span class="string">"/vagrant"</span></span><br></pre></td></tr></table></figure></p>
<p>我们上面介绍过/vagrant目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录。</p>
<p><strong>端口转发设置</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :forwarded_port, guest: <span class="number">80</span>, host: <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>上面这句配置可厉害了，这一行的意思是把对host机器上8080端口的访问请求forward到虚拟机的80端口的服务上，例如你在你的虚拟机上使用nginx跑了一个php应用，那么你在host机器上的浏览器中打开<a href="http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。" target="_blank" rel="external">http://localhost时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。</a><br>个人不建议使用该方法，经常因为两台机子端口占用的问题，导致不能正常通信。还是使用上面说的两种网络方式进行设置吧。</p>
<hr>
<p>上面说的配置方式，均是单机模式，下面说说如何进行集群机器的部署与配置，这是vagrant让我正真激动与兴奋的地方。</p>
<p>看完下面，你会觉得超级简单</p>
<p>现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是redis服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过config.vm.define来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.define :web do |web|</span><br><span class="line">    web.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;web&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    web.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    web.vm.hostname = &quot;web&quot;</span><br><span class="line">    web.vm.network :private_network, ip: &quot;192.168.33.10&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define :redis do |redis|</span><br><span class="line">    redis.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;redis&quot;, &quot;--memory&quot;, &quot;512&quot;]</span><br><span class="line">    end</span><br><span class="line">    redis.vm.box = &quot;CentOs7&quot;</span><br><span class="line">    redis.vm.hostname = &quot;redis&quot;</span><br><span class="line">    redis.vm.network :private_network, ip: &quot;192.168.33.11&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>这里的的设置与设置单台机器非常的类似，如果还需要机器，只需要再配置文件中拷贝一下，然后重新加载一下这个配置文件就ok啦。是不是非常容易？后面我打算学hadoop的时候，就用这种方式来试试。<br>现在只需要重新启动一下vagrant up机器，你就会在虚拟机中看到两台虚拟机欢快的跑起来了。<br>然后这个时候，在使用vagrant ssh登录时，需要指明一下登录的是哪一台机器就ok啦。</p>
<hr>
<p>比如，我要登录到redis中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh redis</span><br></pre></td></tr></table></figure></p>
<p>这么简单就完成登录了。登录成功后，可以使用ping命令，检查一下机器之间是否能够互相通信。</p>
<p>好吧，本地有了如此利器，你想模拟那样的服务器架构，都可以完成了，只有你的单机足够强大，你可以开20台虚拟机，请随意。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vagrant系列一：Vagrant的安装与初识]]></title>
      <url>https://helei112g.github.io/2016/10/30/vagrant%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9AVagrant%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>本系列文章之前首发在csdn上。觉得还不错现在迁移过来。本文主要介绍安装与一些简单介绍。后续会有更深入的探讨。<br><a id="more"></a></p>
<blockquote>
<p>实际上Vagrant只是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统，本书中我们将使用VirtualBox来进行说明，所以第一步需要先安裝Vagrant和VirtualBox。</p>
<p>安装环境：mac<br>注：windows环境下，基本一致</p>
</blockquote>
<h1 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h1><p>直接来到官网 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Downloads</a> 点击下载最新的virtualbox，双击安装，一路傻瓜化完成。</p>
<h1 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装Vagrant</h1><p>网上有说什么使用gem命令来安装的，建议大家别进这个坑了，直接到官网 <a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">https://www.vagrantup.com/downloads.html</a> 下载最新的vagrant，然后双击安装，也是一路傻瓜化，就不说。<br>在windows下安装vagrant，为了写入相应配置到环境变量，可能会要求重新启动一下系统。</p>
<h1 id="如何配置Vagrant"><a href="#如何配置Vagrant" class="headerlink" title="如何配置Vagrant"></a>如何配置Vagrant</h1><hr>
<h2 id="下载一个合适的box"><a href="#下载一个合适的box" class="headerlink" title="下载一个合适的box"></a>下载一个合适的box</h2><p>进行完以上步骤后，就需要考虑我们的虚拟机需要使用什么操作系统了，我这里会以CentOs7.0为例。在以前使用vm的过程中，我们需要自己去下载镜像，然后进行相关的安装，设置系统等等操作。而vagrant的开源社区，提供了很多已经打包好的操作系统，在vagrant的世界里被称为box。在 <a href="http://www.vagrantbox.es/" target="_blank" rel="external">http://www.vagrantbox.es/</a> 这里你可以找到你想要的操作系统box，当然你也可以自己制作一个。后续教程会讲到，这里就不多说。</p>
<h2 id="完成一个box的安装"><a href="#完成一个box的安装" class="headerlink" title="完成一个box的安装"></a>完成一个box的安装</h2><p>我的开发机是Mac，所以我建立了如下的开发环境目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /Users/helei/vagrant</span><br><span class="line">$ cd /Users/helei/vagrant</span><br></pre></td></tr></table></figure></p>
<p>本来，vagrant提供的在线安装，非常便利，但是无奈我国有非常NB的gfw，我为了速度，就先翻墙出去把box下载到本地，然后再进行安装。</p>
<blockquote>
<p>box链接：<a href="https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box" target="_blank" rel="external">https://github.com/tommy-muehle/puppet-vagrant-boxes/releases/download/1.1.0/centos-7.0-x86_64.box</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<p>vagrant box add 是添加box的命令<br>其中｛title｝可以自行设置，我这里使用的是 <em>centos7</em> ，｛url｝是下载到本地box路径。我的路径是：/Users/helei/vagrant/centos-7.0-x86_64.box</p>
<p>下面把一些命令执行后的输出进行展示，方便大家比对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装box</span><br><span class="line">$ vagrant box add CentOs7 /Users/helei/vagrant/centos-7.0-x86_64.box</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Downloading or copying the box...</span><br><span class="line">Extracting box...te: 47.5M/s, Estimated time remaining: --:--:--)</span><br><span class="line">Successfully added box &apos;base&apos; with provider &apos;virtualbox&apos;!</span><br></pre></td></tr></table></figure></p>
<p>box中的镜像文件被放到了：/Users/helei/.vagrant.d/boxes/，如果在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果是才add 的box，就必须执行本步骤，初始化一次后，以后启动系统，就不需要执行本步骤。</span><br><span class="line">$ vagrant init CentOs7</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A `Vagrantfile` has been placed in this directory.</span><br><span class="line">You are now ready to `vagrant up` your first virtual environment!</span><br><span class="line">Please read the comments in the Vagrantfile as well as documentation on `vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure></p>
<p>这样就会在当前目录生成一个 Vagrantfile的文件，里面有很多配置信息，后面我在慢慢说，默认不做任何配置改动，也是可以启动系统的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动系统</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...</span><br><span class="line">[default] Importing base box &apos;base&apos;...</span><br><span class="line">[default] Matching MAC address for NAT networking...</span><br><span class="line">[default] Setting the name of the VM...</span><br><span class="line">[default] Clearing any previously set forwarded ports...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="ssh链接到安装的虚拟机"><a href="#ssh链接到安装的虚拟机" class="headerlink" title="ssh链接到安装的虚拟机"></a>ssh链接到安装的虚拟机</h2><p>经过以上操作后，完成了虚拟机的安装，现在需要登录上虚拟机，进行操作。链接很简单，可以使用第三方（xshell等）shell工具或系统自带的，进行登录<br>在系统中，如mac，可直接使用 <code>vagrant ssh</code> 来完成链接。或者使用第三方如xshell，ip地址是：localhost，端口，需要观察，映射的22端口是多少。一般是2200 或者2222<br>用户名与密码均是： vagrant</p>
<h1 id="vagrant的命令详解"><a href="#vagrant的命令详解" class="headerlink" title="vagrant的命令详解"></a>vagrant的命令详解</h1><hr>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>vagrant box add</td>
<td>添加box的操作</td>
</tr>
<tr>
<td>vagrant init</td>
<td>初始化box的操作，会生成vagrant的配置文件Vagrantfile</td>
</tr>
<tr>
<td>vagrant up</td>
<td>启动本地环境</td>
</tr>
<tr>
<td>vagrant ssh</td>
<td>通过 ssh 登录本地环境所在虚拟机</td>
</tr>
<tr>
<td>vagrant halt</td>
<td>关闭本地环境</td>
</tr>
<tr>
<td>vagrant suspend</td>
<td>暂停本地环境</td>
</tr>
<tr>
<td>vagrant resume</td>
<td>恢复本地环境</td>
</tr>
<tr>
<td>vagrant reload</td>
<td>修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</td>
</tr>
<tr>
<td>vagrant destroy</td>
<td>彻底移除本地环境</td>
</tr>
<tr>
<td>vagrant box list</td>
<td>显示当前已经添加的box列表</td>
</tr>
<tr>
<td>vagrant box remove</td>
<td>删除相应的box</td>
</tr>
<tr>
<td>vagrant package</td>
<td>打包命令，可以把当前的运行的虚拟机环境进行打包</td>
</tr>
<tr>
<td>vagrant plugin</td>
<td>用于安装卸载插件</td>
</tr>
<tr>
<td>vagrant status</td>
<td>获取当前虚拟机的状态</td>
</tr>
<tr>
<td>vagrant global-status</td>
<td>显示当前用户Vagrant的所有环境状态</td>
</tr>
</tbody>
</table>
<p>下一篇，主要讲vagrant的配置，通过配置文件，实现多台虚拟机的启动.能够很方便的实现多台机器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP设计模式：模板方法真的很有用]]></title>
      <url>https://helei112g.github.io/2016/09/09/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>模版方法很好的提现了继承的思想，我用它为核心完成了支付集成的开源项目，在使用过程中受益匪浅。<br><a id="more"></a></p>
<p>在设计模式分类中，模板方法被分在 <strong>行为型模式</strong></p>
<p>在我最近的项目中我也经常使用。然后在看YII的源码时，它的身影也随处可见。忍不住想要将它说一说。希望能够帮助大家解决一些开发中灵活扩展的问题。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以在不改变一个算法的结构的情况下重定义该算法的某些特定的步骤</p>
</blockquote>
<ul>
<li>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</li>
<li>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</li>
</ul>
<p>上面两点是行为型模式的一个特征。以上两点在 <strong>模板方法模式</strong> 中体现的非常明显。</p>
<p>教科书给出的概念读起来总是这么绕口。搞得人云里雾里的。还是结合代码来说吧。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="http://www.phppan.com/wp-content/uploads/2010/09/Template.jpg" alt="image"></p>
<h1 id="模板方法code案例"><a href="#模板方法code案例" class="headerlink" title="模板方法code案例"></a>模板方法code案例</h1><p>为了让大家能够在实际中看到设计模式的使用。我就直接用YII中的一些代码片段来讲。然后大家可以下载YII下来。然后自己对照看一看。</p>
<p>根据上面的类图。首先需要一个抽象的父类。它里边定义了一个 <code>templateMethod</code>  这个方法内部会调用 <code>primitiveOperation1</code>  <code>primitiveOperation2</code> 这两个方法。但是调用的两个发放是抽象的。要在子类中来具体决定实现。</p>
<p>先把示例代码写出来，大家看一看</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 顶层组织逻辑的方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation1();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;primitiveOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个抽象类定义好了调用的层次。凡是继承了它的子类，都需要实现这两个方法，并且完成自己相应的逻辑。比如一个子类继承了它。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 基本方法1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation1&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * 基本方法2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">primitiveOperation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'primitiveOperation2&lt;br /&gt;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上基本上就是模板方法模式的全部代码。不知道大家是否从中领教到它的厉害之处？我先不解释，接下来看看YII中对这种设计模式的应用</p>
<h1 id="YII中的模板方法"><a href="#YII中的模板方法" class="headerlink" title="YII中的模板方法"></a>YII中的模板方法</h1><p>凡是用过YII的都知道，它有一个 <code>Object</code> 类。这个类是整个YII的基础。今天我们不说YII。单说设计模式。就略过不说了。下面是简化后的 <code>Object代码</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Configurable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($config = [])</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($config)) &#123;</span><br><span class="line">            Yii::configure(<span class="keyword">$this</span>, $config);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意这个方法</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// YII中为它定义了一个空实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YII在 <code>Object</code> 的构造函数中，调用 <code>Object::init()</code> 这个方法。但是这个方法是一个空实现，因此具体要init的东西，延迟到了子类进行实现，</p>
<p>看看YII的代码，就知道基本上所有的类都是继承自这个类，每个类的init都可以进行个性化定制。</p>
<p>它的实现，我们可以看看 <code>ActiveController</code> 中代码的实现</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActiveController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::init();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;modelClass === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidConfigException(<span class="string">'The "modelClass" property must be set.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Controller</code> 也是继承自 <code>Object</code> 大家可以自己追踪一下代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法模式使用的范围非常广泛。总结一下它的特点</p>
<ul>
<li>将具体的一些实现延迟到子类，可以减少父类初始化的压力</li>
<li>父类只定义调用步骤，具体每一步的实现由子类自己决定</li>
<li>这样的结构利用了一种反射的思路，由父类来调用子类的具体实现方法</li>
<li>很好的进行了代码的复用</li>
</ul>
<p>在YII中有很多模板方法的使用，大家可以自己去阅读代码看一看。这种设计模式带来的一个麻烦的地方是查看代码的不方便。<br>比如：经常继承一个类后实现了一些方法，但是这个方法的调用关系一头雾水，如果遇到这种情况，建议去父类看看是否有个方法组织调用了你重写的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信企业付款功能]]></title>
      <url>https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>可以利用该接口，完成转账功能，目前仅微信支持，支付宝已关闭。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a></p>
<p>这个功能与支付宝的批量付款到支付宝帐号功能类似。但是当前支付宝这个接口已经停止审核了。</p>
<p>当前很多提问平台就用到了这两个平台。比如［来问医生］，你提的问题如果被人看了。医生得0.5元，你得0.5元。然后累积够1元后，［来问医生］就会通过微信的企业付款功能给你的微信余额增加1元。</p>
<h1 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">TransferContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>,<span class="comment">// 微信转款时，为用户所关注公众号的openid</span></span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信的企业付款， 仅支持单笔</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initTransfer(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转账数据</td>
<td>转账数据详细信息，具体内容如下</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>对于微信该参数不需要，但请保留，后期可能支持批量退款需要</td>
<td>否</td>
</tr>
<tr>
<td>user_account</td>
<td>用户openid</td>
<td>商户appid下，某用户的openid</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款用户姓名</td>
<td>收款用户真实姓名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>金额</td>
<td>企业付款金额，单位为元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>企业付款描述信息</td>
<td>企业付款操作说明信息。</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>是否成功</td>
<td>失败会返回错误原因。T:成功  F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误原因</td>
<td>为T时有返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>成功时数据</td>
<td>成功时返回的具体数据</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>商户订单号</td>
<td>商户订单号，需保持唯一性</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>微信订单号</td>
<td>企业付款成功，返回的微信订单号</td>
<td>否</td>
</tr>
<tr>
<td>payment_time</td>
<td>微信支付成功时间</td>
<td>企业付款成功时间</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入微信退款接口]]></title>
      <url>https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>买的东西不喜欢了，想要还给商家，申请后商家自动退换购买商品时的买家支付的费用。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.0版本</a> </p>
<p>微信的退款操作，通过封装与前面<a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝退款</a>除了配置文件，基本一样。</p>
<p>退款代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">RefundContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$config = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxa244db59a34996fc'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'1331302101'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'adslkfjiKQJLAIQLJ393201482333333'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时 退款  转款，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'4007572001201607098672633287'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'5'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'5'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'微信测试金额退款'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信退款</span></span><br><span class="line">    $type = Config::WEIXIN;</span><br><span class="line">    $refund-&gt;initRefund(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure></p>
<p>当前sdk支付宝可一次退款多笔数据。微信仅能每次退款1笔（如果想要实现一次退订多笔订单，可在客户端通过循环来处理。）</p>
<p>接下来解释下相关的配置信息</p>
<p>微信的配置文件解释参考 <a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/">微信的三种支付方式接入：APP支付、公众号支付、扫码支付</a> 中的微信配置信息。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>总金额</td>
<td>微信交易对应的交易总金额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>本次申请的退款金额，退款金额不能大于总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款的理由，可在用户端查看到</td>
<td>是</td>
</tr>
</tbody>
</table>
<h1 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p><strong>response</strong> 数据描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>微信订单号</td>
<td>微信订单号，下单成功后，微信返回</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统内部的订单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>申请退款金额</td>
<td>退款总金额,单位为元(已被我处理),可以做部分退款</td>
<td>否</td>
</tr>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>订单总金额，单位为元，最多两位小数</td>
<td>否</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信支付订单、退款订单、转款订单的查询]]></title>
      <url>https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>主要介绍相关订单的查询，简化针对不同类型订单（支付的、退单的、转款的）的查询工作。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a></p>
<p>微信并未提供一个统一的查询接口。对应每种查询均需要不同的api。为了便于大家在项目中使用，忽略细节。对以上三种进行了封装。通过工厂的方式降低调用成本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">QueryContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交易号查询，  推荐</span></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">//'order_no'    =&gt; '2016011402433464',// 商户订单号</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'4007572001201607098672633287'</span>,<span class="comment">// 微信订单查询  微信退款单查询</span></span><br><span class="line">    <span class="comment">//'trans_no'  =&gt; '1007570439201601142692427764', // 微信批量转款查询</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 微信订单查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::WEIXIN, $wxconfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信退款订单状态查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_REFUND, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信企业付款查询</span></span><br><span class="line">    <span class="comment">//$query-&gt;initQuery(Config::WEIXIN_TRANS, $wxconfig);</span></span><br><span class="line"></span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订单查询非常简单。对于微信支付订单以及退款订单可以根据微信支付的流水号进行查询。对于微信支付的订单还可根据商户的订单号进行查询。但是强烈建议通过微信自身的流水号进行查询。</p>
<p>对于批量转款查询。需要提供再转款时，生产的转款单号（此单号是由商家自行生产的）。这里我也蛮迷惑，为什么不提供使用微信返回的转款流水号进行查询呢？</p>
<p>接下来对返回值进行解释,以下结构为一个顶层结构</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<h2 id="微信支付订单返回值"><a href="#微信支付订单返回值" class="headerlink" title="微信支付订单返回值"></a>微信支付订单返回值</h2><p>支付订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="微信退款订单"><a href="#微信退款订单" class="headerlink" title="微信退款订单"></a>微信退款订单</h2><p>退款有以下两点需要注意</p>
<ul>
<li>交易时间超过一年的订单无法提交退款；</li>
<li>微信支付退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。一笔退款失败后重新提交，要采用原来的退款单号。总退款金额不能超过用户实际支付金额。</li>
</ul>
<p>由于一笔支付订单，可能存在多笔退单的情况，因此退款记录将返回一个数组</p>
<p>退款订单中关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额，单位为元，最多两位小数</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信交易号</td>
<td>微信系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>其结构是一个数组，每一个元素包含一个退单信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><code>refund_data</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>商户退款单号</td>
<td>商户退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_id</td>
<td>微信退款单号</td>
<td>微信退款单号</td>
<td>是</td>
</tr>
<tr>
<td>refund_channel</td>
<td>退款渠道</td>
<td>ORIGINAL—原路退款  BALANCE—退回到余额</td>
<td>是</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款总金额,单位为元,可以做部分退款</td>
<td>是</td>
</tr>
<tr>
<td>refund_status</td>
<td>退款状态</td>
<td>SUCCESS—退款成功  FAIL—退款失败  PROCESSING—退款处理中  NOTSURE—未确定，需要商户原退款单号重新发起  CHANGE—转入代发</td>
<td>是</td>
</tr>
<tr>
<td>recv_accout</td>
<td>退款入账账户</td>
<td>退款入账账户</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="转款订单查询结果"><a href="#转款订单查询结果" class="headerlink" title="转款订单查询结果"></a>转款订单查询结果</h2><pre><code>&apos;trans_id&apos;  =&gt; $data[&apos;detail_id&apos;],// 付款单号
&apos;trans_status&apos;  =&gt; $data[&apos;status&apos;],// 转账状态
&apos;reason&apos;    =&gt; $data[&apos;reason&apos;],// 失败原因
&apos;buyer_id&apos;   =&gt; $data[&apos;openid&apos;],
&apos;trans_name&apos;   =&gt; $data[&apos;transfer_name&apos;],// 收款用户姓名
&apos;trans_time&apos;   =&gt; $data[&apos;transfer_time&apos;],
&apos;desc&apos;   =&gt; $data[&apos;desc&apos;],// 付款描述
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>付款金额</td>
<td>付款金额  单位元</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户单号</td>
<td>商户使用查询API填写的单号的原路返回.</td>
<td>是</td>
</tr>
<tr>
<td>trans_id</td>
<td>付款单号</td>
<td>调用企业付款API时，微信系统内部产生的单号</td>
<td>是</td>
</tr>
<tr>
<td>trans_status</td>
<td>转账状态</td>
<td>SUCCESS:转账成功   FAILED:转账失败  PROCESSING:处理中</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>失败原因</td>
<td>如果失败则有失败原因</td>
<td>否</td>
</tr>
<tr>
<td>buyer_id</td>
<td>收款用户openid</td>
<td>收款用户openid</td>
<td>是</td>
</tr>
<tr>
<td>trans_name</td>
<td>收款用户姓名</td>
<td>真实姓名，如果是需要实名验证，则会返回</td>
<td>否</td>
</tr>
<tr>
<td>trans_time</td>
<td>转账时间</td>
<td>发起转账的时间  格式：2015-04-21 20:00:00</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>付款描述</td>
<td>付款时候的描述</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信的三种支付方式接入：APP支付、公众号支付、扫码支付]]></title>
      <url>https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>微信支付：app支付、公众号支付、扫码支付使用文档。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>微信的支付逻辑与支付宝的支付有一些差别。为了让客户端忽略这些差别，统一调用。本sdk做了对应处理。</p>
<p>＃ SDK调用</p>
<p>微信支付不同接口需要的参数会有差别。请大家在使用接口时，仔细查看文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">ChargeContext</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Config</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Common</span>\<span class="title">PayException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付，必须设置时区，否则发生错误</span></span><br><span class="line">date_default_timezone_set(<span class="string">'Asia/Shanghai'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$payData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信扫码支付，需要设置的参数</span></span><br><span class="line">$payData[<span class="string">'product_id'</span>]  = <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信公众号支付，需要的参数</span></span><br><span class="line">$payData[<span class="string">'openid'</span>] = <span class="string">'otijfvr2oMz3tXnaQdKKbQeeBmhM'</span>;<span class="comment">// 需要通过微信提供的api获取该openid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 包含客户的配置文件</span><br><span class="line"> * 本次 2.0 版本，主要的改变是将配置文件独立出来，便于客户多个账号的情况</span><br><span class="line"> * 已经使用不同方式读取配置文件，如：db  file   cache等</span><br><span class="line"> */</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 实例化支付环境类，进行支付创建</span><br><span class="line"> */</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 扫码支付</span></span><br><span class="line">    $type = Config::WX_CHANNEL_QR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 APP支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_APP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信 公众号支付</span></span><br><span class="line">    <span class="comment">//$type = Config::WX_CHANNEL_PUB;</span></span><br><span class="line">    $charge-&gt;initCharge($type, $wxconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::WX_CHANNEL_QR) &#123;</span><br><span class="line">    $url = urlencode($ret);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;img alt='扫码支付' src='http://paysdk.weixin.qq.com/example/qrcode.php?data=&#123;$url&#125;' style='width:150px;height:150px;'/&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($type === Config::WX_CHANNEL_PUB) &#123;</span><br><span class="line">    $json = $ret;</span><br><span class="line">    var_dump($json);<span class="keyword">exit</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (stripos($type, <span class="string">'wx'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里扫码支付与公众号支付分别需要提供不同的参数。请一定注意进行区分。否则调用相应端口会抛出异常。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>app_id</td>
<td>公众账号ID/应用id</td>
<td>微信分配的公众账号ID</td>
<td>是</td>
</tr>
<tr>
<td>mch_id</td>
<td>商户号</td>
<td>微信支付分配的商户号</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>加密的key</td>
<td>在商户中心设置</td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>通知地址</td>
<td>接收微信支付异步通知回调地址，通知url必须为直接可访问的url，不能携带参数。</td>
<td>是</td>
</tr>
<tr>
<td>time_expire</td>
<td>交易过期时间</td>
<td>单位为分钟，过期后无法再次支付</td>
<td>是</td>
</tr>
<tr>
<td>cert_path</td>
<td>密钥文件</td>
<td>可在微信商户后台中下载</td>
<td>否，退款需要</td>
</tr>
<tr>
<td>key_path</td>
<td>密钥文件</td>
<td>可在商户中心下载</td>
<td>否，退款需要</td>
</tr>
</tbody>
</table>
<p>这里需要注意的是，app_id，由于微信的三个支付接口，需要对应两个不同的app_id。因此再开发中一定要注意。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
<tr>
<td>product_id</td>
<td>商品ID</td>
<td>扫码支付，此参数必传。此id为二维码中包含的商品ID，商户自行定义。</td>
<td>可选</td>
</tr>
<tr>
<td>openid</td>
<td>用户标识</td>
<td>公众号支付，此参数必传，用户在商户appid下的唯一标识。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<h1 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h1><p>三种支付方式返回值因为处理方式不同，微信方面返回了不同的类型。</p>
<ul>
<li>app支付返回了需要调用的数组。调用客户端的方式 <a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2" target="_blank" rel="external">查看微信文档</a></li>
<li>扫码支付返回了一个地址。可生成一个二维码，完成支付。</li>
<li>公众号支付，返回的是一个json数据。可直接放入微信的sdk完成jsapi调用。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密批量转款接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>转款接口，支付宝已经停止审核啦，目前可以用微信的企业付款。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口蛮有用的，不过现阶段支付宝已经停止审核啦！微信的转账功能还可以继续使用。企业可以转账到其他支付宝账户。对于企业活动非常有帮助，比如：购买返现呀！</p>
<p>虽然现在已经不接收新的审核，但是我还是将该功能进行了集成，因为指不定什么时候又开放了，毕竟微信都有这个功能，支付宝不搞出来，实在说不过去。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成转款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转款数据</span></span><br><span class="line">$transData = [</span><br><span class="line">    <span class="string">'trans_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'trans_data'</span>   =&gt; [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'serial_no'</span> =&gt; createPayid(),</span><br><span class="line">            <span class="string">'user_account'</span> =&gt; <span class="string">'dayugog@gmail.com'</span>,</span><br><span class="line">            <span class="string">'user_name'</span> =&gt; <span class="string">'愚不可及'</span>,</span><br><span class="line">            <span class="string">'trans_fee'</span> =&gt; <span class="string">'0.01'</span>,</span><br><span class="line">            <span class="string">'desc'</span>  =&gt; <span class="string">'测试批量转款'</span>,</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> TransferContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initTransfer(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;transfer($transData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>这个接口也是需要管理员输入支付密码，才能够完成，完成后也会回调。回调过程请参考 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付的回调统一处理</a> 已经说明。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>trans_no</td>
<td>转款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>trans_data</td>
<td>转款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>trans_data数据组成</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>serial_no</td>
<td>流水号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>user_account</td>
<td>收款方账号</td>
<td>收款方的支付宝账号，支持邮箱和手机号2种格式。</td>
<td>是</td>
</tr>
<tr>
<td>user_name</td>
<td>收款账号姓名</td>
<td>收款方的支付宝账户名。</td>
<td>是</td>
</tr>
<tr>
<td>trans_fee</td>
<td>付款金额</td>
<td>向该账号转入多少金额，单位元</td>
<td>是</td>
</tr>
<tr>
<td>desc</td>
<td>备注说明</td>
<td>可以是转款理由等，如：8月工资2W</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>这个地方SDK总做了很多工作，简化了相当多的参数，大家可以去对照原接口查看一下。<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.rVbILN&amp;treeId=64&amp;articleId=104804&amp;docType=1" target="_blank" rel="external">支付宝原接口地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝有密退款接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>可针对订单完成退款操作，但是需要输入密码。不是谁都可以操作。微信退款则可以根据密钥文件自动完成，无须人为干预。<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>这个接口主要用于退款操作。之前没有接入该功能时，商城用户如果想要退款，我们需要先查到对应用户的支付流水号，然后写退款申请给财务，财务到支付宝进行查询。完了之后原路退回。然后告诉程序，程序再去修改订单状态。</p>
<p>这样的流程不仅麻烦。而且充满不安全性。如果程序误操作（或者是心情太差了），操作为其他人员，那么这将会为企业带来很大的风险。</p>
<h1 id="SDK调用"><a href="#SDK调用" class="headerlink" title="SDK调用"></a>SDK调用</h1><p>支付宝支持多笔退款。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生成退款单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time()).substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>).rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退款数据</span></span><br><span class="line">$reundData = [</span><br><span class="line">    <span class="string">'refund_no'</span> =&gt; createPayid(),</span><br><span class="line">    <span class="string">'refund_data'</span>   =&gt; [</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016011421001004330041239366'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款1'</span>],</span><br><span class="line">        [<span class="string">'transaction_id'</span> =&gt; <span class="string">'2016031521001004330271745693'</span>, <span class="string">'amount'</span>   =&gt; <span class="string">'0.01'</span>, <span class="string">'refund_fee'</span> =&gt; <span class="string">'0.01'</span>, <span class="string">'reason'</span> =&gt; <span class="string">'测试退款2'</span>],</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$refund = <span class="keyword">new</span> RefundContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $refund-&gt;initRefund(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $refund-&gt;refund($reundData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转支付宝</span></span><br><span class="line">header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上请求发送完毕后，会跳转到生成的url。界面如下：</p>
<p><img src="https://helei112g.github.io/images/ali-refund.png" alt="image"></p>
<p>这时候，只需要要输入支付密码。就可完成退款。确认完毕后会自动完成异步通知。异步通知数据内容在 <a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付的回调统一处理</a> 已经说明。</p>
<p>备注：支付宝支持一次退款多笔。也可单次退款一笔，请自行根据情况进行设置。</p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>refund_no</td>
<td>退款单号</td>
<td>由商家自定义生成，可由字母、数字组成</td>
<td>是</td>
</tr>
<tr>
<td>refund_data</td>
<td>退款数据</td>
<td>详细内容见后表，它是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>refund_data数据</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功时，异步通知时有返回</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>订单总金额</td>
<td>订单总金额，应该等于支付时的金额</td>
<td>否</td>
</tr>
<tr>
<td>refund_fee</td>
<td>退款金额</td>
<td>退款金额，不能超过支付的总金额</td>
<td>是</td>
</tr>
<tr>
<td>reason</td>
<td>退款理由</td>
<td>退款理由</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>一笔订单，可分多次进行退款处理。比如：一笔支付100元的订单。可分为10次，每次退款10元。该思路可扩展一下，就可实现提现功能（原路返回），想要具体了解提现功能，可咨询我！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝单笔订单查询接口]]></title>
      <url>https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>查询支付宝订单状态<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>巴西奥运会来了，刚好我又是做体育行业的互联网。哎！这个月又要加班成狗了。最近遇到好多莫名其妙的问题，待我忙完这段，再跟大家分享下。今天还是继续说说 <a href="https://github.com/helei112g/payment" target="_blank" rel="external">Payment项目</a><br>今天主要说说支付宝订单查询接口。</p>
<h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><p>废话废话不多说。直接上支付宝订单查询的代码。微信的订单查询与此类似。后续也会更新文档。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$data = [</span><br><span class="line">    <span class="comment">// 通过支付宝交易号查询，  推荐  效率更高</span></span><br><span class="line">    <span class="string">'transaction_id'</span>    =&gt; <span class="string">'2016011421001004330041239366'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过订单号查询</span></span><br><span class="line">    <span class="string">'order_no'</span>    =&gt; <span class="string">'2016011402433464'</span>,<span class="comment">// 支付宝</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$query = <span class="keyword">new</span> QueryContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝查询</span></span><br><span class="line">    $query-&gt;initQuery(Config::ALI, $aliconfig);</span><br><span class="line">    $ret = $query-&gt;query($data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure>
<p>非常简单，只需要提供支付宝的流水号，或者商家自己生成的订单号，就可完成订单详情的查询，当然前提是，依然要去签约这个接口（觉得支付宝真扯淡，都能够支付了，为什么查询还要单独签约？这一点微信比它强）</p>
<p>如果同时提供了 <code>transaction_id</code> 跟 <code>order_no</code> 这两个参数，会优先使用 <code>transaction_id</code> ,因为他的效率要高的多。</p>
<p>代码完成了下面分别解释下请求的参数。以及返回参数。关于支付宝的配置参数，请参考 <a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">PHP接入支付宝手机网站支付、移动支付接口</a></p>
<h1 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h1><p>查询订单的参数非常简单。这里能够查询的仅指：支付成功后的订单</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction_id</td>
<td>支付宝流水号</td>
<td>支付成功后，异步通知中会返回</td>
<td>二选一</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户生成的唯一订单号</td>
<td>二选一</td>
</tr>
</tbody>
</table>
<p>对于上表中的数据，两个字段二选一即可。推荐使用 <code>transaction_id</code> ，该字段查询效率更高。如果两个字段同时提供，会优先使用 <code>transaction_id</code>。</p>
<p>请求后，程序会向支付宝进行查询。查询完成后，会将返回的数据做一定处理然后返回给客户端。</p>
<h1 id="返回参数"><a href="#返回参数" class="headerlink" title="返回参数"></a>返回参数</h1><p>查询存在两种情况，失败，成功，分别对返回字段含义进行说明。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_success</td>
<td>成功标识</td>
<td>请求是否成功，T:成功，F:失败</td>
<td>是</td>
</tr>
<tr>
<td>error</td>
<td>错误提示</td>
<td>只有is_success=F时才返回</td>
<td>否</td>
</tr>
<tr>
<td>response</td>
<td>响应数据</td>
<td>查询成功后返回的数据，一个数组，is_success=T时返回</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>关于 <code>response</code> 中包含字段的描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>针对查询返回的数据，调用者可进行相关的业务处理。如果需要更多信息可联系我进行定制开发，也可自行更改代码完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付的回调统一处理]]></title>
      <url>https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>支付成功的订单，都需要通过第三方的回调来告知自身服务器，任务已经完成，为了让使用者专注自身的业务，这个接口封装了一些基础处理，如：验签、数据解析等<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>经过这一段时间，终于把支付宝支付相关接口完成了。文档将陆续更新。这里先把回调的文档补充完成。这样结合之前 提供的 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">支付宝即时到帐接口</a> 才能形成一个闭环。完成一次完整的支付流程。</p>
<h1 id="回调接口介绍"><a href="#回调接口介绍" class="headerlink" title="回调接口介绍"></a>回调接口介绍</h1><blockquote>
<p>支付服务商(支付宝、微信、PayPal等)处理完支付数据后。会将处理的结果数据通过服务器主动通知的方式通知给商户网站。这些处理结果数据就是服务器异步通知参数。</p>
</blockquote>
<p>简单来说，就是支付成功后，支付服务商告诉你，钱已经到账了，你应该把别个买的东西给别个了。</p>
<p>由于本次发布的接口主要都是与支付宝相关，因此本次回调的部分代码也主要先上支付宝的。微信等后期开发完成将更新相关文档。</p>
<p>针对不同的回调，我提供了统一的调用方式，让客户端专注自己的业务。不在处理支付相关的签名验证、来源验证的问题。下面代码是统一的回调处理代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置文件</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,<span class="comment">// 请填写自己的支付宝账号信息</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxx'</span>,<span class="comment">// 此密码无效，请填写自己对应设置的值</span></span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转款接口，必须配置以下两项</span></span><br><span class="line">    <span class="string">'account'</span>   =&gt; <span class="string">'xxxxxxx@126.com'</span>,</span><br><span class="line">    <span class="string">'account_name'</span> =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信配置文件</span></span><br><span class="line">$wxconfig = [</span><br><span class="line">    <span class="string">'app_id'</span>    =&gt; <span class="string">'wxxxx'</span>,  <span class="comment">// 公众账号ID</span></span><br><span class="line">    <span class="string">'mch_id'</span>    =&gt; <span class="string">'xxxx'</span>,<span class="comment">// 商户id</span></span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxx'</span>,<span class="comment">// md5 秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'notify_url'</span>    =&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">'time_expire'</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及资金流动时，需要提供该文件</span></span><br><span class="line">    <span class="string">'cert_path'</span> =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_cert.pem'</span>,</span><br><span class="line">    <span class="string">'key_path'</span>  =&gt; dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">'wx'</span> . DIRECTORY_SEPARATOR . <span class="string">'apiclient_key.pem'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异步通知上下文</span></span><br><span class="line">$notify = <span class="keyword">new</span> NotifyContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的业务逻辑类。处理如：订单更新</span></span><br><span class="line">$callback = <span class="keyword">new</span> TestNotify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝回调</span></span><br><span class="line">    <span class="comment">//$notify-&gt;initNotify(Config::ALI, $aliconfig);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 微信回调</span></span><br><span class="line">    $notify-&gt;initNotify(Config::WEIXIN, $wxconfig);</span><br><span class="line">    $notify-&gt;notify($callback);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类 <code>TestNotify</code> 的注意事项 ，一定要继承 <code>PayNotifyInterface</code> 这个类</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Payment</span>\<span class="title">Notify</span>\<span class="title">PayNotifyInterface</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNotify</span> <span class="keyword">implements</span> <span class="title">PayNotifyInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 客户端的业务逻辑，</span><br><span class="line">     * <span class="doctag">@param</span> array $data</span><br><span class="line">     * <span class="doctag">@return</span> bool  返回值一定是bool值</span><br><span class="line">     * <span class="doctag">@author</span> helei</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyProcess</span><span class="params">(array $data)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 一般支付的处理业务</span></span><br><span class="line">        <span class="number">1.</span> 检查订单是否存在</span><br><span class="line">        <span class="number">2.</span> 检查金额是否正确</span><br><span class="line">        <span class="number">3.</span> 检查订单是否已经处理过（防止重复通知）</span><br><span class="line">        <span class="number">4.</span> 更新订单</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TestNotify::notifyProcess()</code> 方法中，我注释了常规的订单处理流程。这个地方客户端可根据自己的情况进行适当调整。只是返回结果一定需要 <strong>布尔值</strong></p>
<p>现在的重点是 <code>TestNotify::notifyProcess()</code> 方法中的参数 $data 中具体包含的值。根据不同的回调业务，返回的值也不一样。具体请往下看。</p>
<h1 id="支付宝回调通知类型"><a href="#支付宝回调通知类型" class="headerlink" title="支付宝回调通知类型"></a>支付宝回调通知类型</h1><p>支付宝的回调，与支付相关的对应三种类型。</p>
<ul>
<li>trade_status_sync  支付行为相关的异步通知</li>
<li>batch_refund_notify   有密批量退款的异步通知</li>
<li>batch_trans_notify   有密批量付款到支付宝账号的通知</li>
</ul>
<h2 id="trade-status-sync-异步通知返回数据"><a href="#trade-status-sync-异步通知返回数据" class="headerlink" title="trade_status_sync 异步通知返回数据"></a>trade_status_sync 异步通知返回数据</h2><p>该回调发生在：移动支付、即时到帐、手机网站支付接口调用后，如果支付成功，支付宝会发起回调接口。</p>
<p>返回的对应数据如下表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>订单的关键字</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>提交订单时的body值</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易金额</td>
<td>本次订单总金额</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户网站唯一订单号</td>
<td>商户生成的订单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>买家支付宝账户号</td>
<td>可以是Email或手机号码。</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>支付成功与否，可取值：success  not_pay</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>支付宝交易号</td>
<td>支付宝系统中的交易流水号，可用于查询订单状态</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>交易付款时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>传入到 <code>TestNotify::notifyProcess()</code> 中的数组，包括以上key。可根据以上内容进行业务处理。</p>
<h2 id="batch-refund-notify-异步通知返回数据"><a href="#batch-refund-notify-异步通知返回数据" class="headerlink" title="batch_refund_notify 异步通知返回数据"></a>batch_refund_notify 异步通知返回数据</h2><p>本类回调发生在操作退款后，支付宝会通知服务器是否退款成功。退款的界面，如下图：</p>
<p><img src="http://note.youdao.com/yws/public/resource/82ee87138ba987799b398e12b6c79c95/685E18BF0FF041C780F3E1721DA9A26A" alt="image"></p>
<p>输入支付密码后，就可完成退款。退款后支付宝会向商户服务器进行异步通知。他返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>refund_no</td>
<td>商户网站唯一退单号</td>
<td>商户生成的退单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>success_num</td>
<td>退款成功总数</td>
<td>0&lt;= success_num&lt;= 总退款笔数</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="batch-trans-notify-异步通知返回数据"><a href="#batch-trans-notify-异步通知返回数据" class="headerlink" title="batch_trans_notify 异步通知返回数据"></a>batch_trans_notify 异步通知返回数据</h2><p>该回调发生在批量付款后。返回的数据如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>channel</td>
<td>渠道</td>
<td>本处取值： ali</td>
<td>是</td>
</tr>
<tr>
<td>trans_no</td>
<td>商户网站唯一转账单号</td>
<td>商户生成的转账单号，必须确保在系统中唯一</td>
<td>是</td>
</tr>
<tr>
<td>pay_name</td>
<td>付款账号姓名</td>
<td>如果是个人为昵称，公司则为公司名称</td>
<td>是</td>
</tr>
<tr>
<td>pay_account</td>
<td>付款账号</td>
<td>邮箱或者手机号码</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>通知时间</td>
<td>格式为2016-07-28 16:01:01</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>success</td>
<td>转账成功的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
<tr>
<td>fail</td>
<td>转账失败的详细信息</td>
<td>返回的是一个数组</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>备注：</strong></p>
<ul>
<li>success返回的数组中，单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^成功标识(S)^成功原因(null)^支付宝内部流水号^完成时间。</p>
</blockquote>
<ul>
<li>fail返回数据中的单条记录格式如下：</li>
</ul>
<blockquote>
<p>流水号^收款方账号^收款账号姓名^付款金额^失败标识(F)^失败原因^支付宝内部流水号^完成时间。</p>
</blockquote>
<p>OK。到此支付宝相关的回调通知数据，已经全部处理完成。这里需要大家注意一个问题，上面的数据并不是完整的支付宝返回数据。大部分经过了我的简化，如果有需要的参数，没有返回可执行修改源码或者联系我。</p>
<h1 id="微信支付回调"><a href="#微信支付回调" class="headerlink" title="微信支付回调"></a>微信支付回调</h1><p>微信的回调代码部分与支付宝相同。不同的主要是返回值</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>amount</td>
<td>订单金额</td>
<td>微信默认为分，此处以处理为元，两位小数</td>
<td>是</td>
</tr>
<tr>
<td>channel</td>
<td>支付渠道</td>
<td>可取之为：ali   wx  此处为wx</td>
<td>是</td>
</tr>
<tr>
<td>order_no</td>
<td>商户订单号</td>
<td>商户系统的订单号，与请求一致。</td>
<td>是</td>
</tr>
<tr>
<td>buyer_id</td>
<td>用户标识</td>
<td>用户在商户appid下的唯一标识</td>
<td>是</td>
</tr>
<tr>
<td>trade_state</td>
<td>交易状态</td>
<td>表示交易成功，返回值：success</td>
<td>是</td>
</tr>
<tr>
<td>transaction_id</td>
<td>微信支付订单号</td>
<td>微信支付订单号</td>
<td>是</td>
</tr>
<tr>
<td>time_end</td>
<td>支付完成时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_time</td>
<td>异步通知发生时间</td>
<td>支付完成时间，格式为yyyy-MM-dd HH:mm:ss</td>
<td>是</td>
</tr>
<tr>
<td>notify_type</td>
<td>通知类型</td>
<td>此处为：trade  表示交易</td>
<td>是</td>
</tr>
<tr>
<td>extra_param</td>
<td>商户自定义参数</td>
<td>仅即时到帐支持</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>大家可以对比支付宝中异步通知的返回数据。对相关数据均做了命令统一、数据单位格式统一。方便再业务中进行统一处理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝手机网站支付、移动支付接口]]></title>
      <url>https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>支付宝手机网站、移动支付（app）接口。统一的接入方式，便于项目管理<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>前面已经说完了 PHP接入支付宝 即时到帐接口</p>
<p>回调接口也已经完成。这篇主要讲 <strong>手机网站支付</strong> 、 <strong>移动支付</strong> 接口的调用。调用方式与即时到帐 基本一样。</p>
<p>关于代码部分的详细解释，请 参看 <a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">PHP接入支付宝 即时到帐接口</a></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 订单数组</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付宝配置信息</span></span><br><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化环境类</span></span><br><span class="line"></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 支付宝即时到帐接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WEB;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 手机网站支接口</span></span><br><span class="line">    <span class="comment">// $type = Config::ALI_CHANNEL_WAP;</span></span><br><span class="line">    <span class="comment">// $charge-&gt;initCharge($type, $aliconfig);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝 移动支付接口</span></span><br><span class="line">    $type = Config::ALI_CHANNEL_APP;</span><br><span class="line">    $charge-&gt;initCharge($type, $aliconfig);</span><br><span class="line">    $ret = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($type === Config::ALI_CHANNEL_APP) &#123;</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 跳转支付宝</span></span><br><span class="line">    header(<span class="string">"Location:&#123;$ret&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>oK！大家仔细看代码。唯一不同的，仅仅是支付的方式这个常量。<br>目前常量的含义</p>
<ul>
<li>Config::ALI_CHANNEL_WEB  及时到账接口，主要用于网站支付</li>
<li>Config::ALI_CHANNEL_WAP  手机网站支付接口，主要用于手机浏览器</li>
<li>Config::ALI_CHANNEL_APP  移动支付接口，主要用于原生APP</li>
</ul>
<p>调用方式非常统一，传入的参数也被最大程度的统一化。简化了客户端的调用。这里主要对参数进行一些说明。</p>
<h1 id="支付宝配置数据"><a href="#支付宝配置数据" class="headerlink" title="支付宝配置数据"></a>支付宝配置数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$aliconfig = [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>是</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>是</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>否</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的url路径。仅在即时到账接口有效</td>
<td>否</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="订单数据"><a href="#订单数据" class="headerlink" title="订单数据"></a>订单数据</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'0.01'</span>,<span class="comment">// 单位为元 ,最小为0.01</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'      测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"show_url"</span>  =&gt; <span class="string">'http://mall.tiyushe.com/goods/23.html'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>   =&gt; <span class="string">'自定义参数'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>是</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>是</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>是</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>是</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>是</td>
</tr>
<tr>
<td>show_url</td>
<td>商品展示网址</td>
<td>收银台页面上，商品展示的超链接。</td>
<td>手机网站支付接口：必须，其他：可选</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。仅在即时到帐接口有效</td>
<td>是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：策略模式的实际应用]]></title>
      <url>https://helei112g.github.io/2016/07/23/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>多学两个设计模式总是好的，自己不写，但是总要看别人的代码吧？<br><a id="more"></a></p>
<p>最近写了一个集成各家支付的开源项目（支付宝与微信）。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目地址</a>。让调用支付变得更加简单、统一。目前已经在<a href="http://mall.tiyushe.com/" target="_blank" rel="external">公司商城</a>推行使用，上海<a href="http://yimishiji.com/" target="_blank" rel="external">一米市集</a>也采用了这个支付集成项目。</p>
<p>我可不是打广告哦，只是为了让大家可以有一个只管的了解渠道。可以去看看。</p>
<p>今天主要聊的不是支付，而是说说其中使用的一个设计模式：策略模式。</p>
<h1 id="策略模式的定义解析"><a href="#策略模式的定义解析" class="headerlink" title="策略模式的定义解析"></a>策略模式的定义解析</h1><blockquote>
<p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p>
</blockquote>
<p>这是书本上给的定义，是不是完全搞不懂？我结合支付，再来给你解释一下，一定就赫然开朗啦！</p>
<p>首先是这句 <strong>让算法独立于使用它的客户而变化</strong>  （我是倒着在分析哦）。<br>这是什么意思？也就是说实现一个功能，有多个方法，而选择这个方法的控制权不要交给客户端，也就说了，我换了实现方法，客户端是不需要改代码的。</p>
<p>那么要做到这样子，必然提供给客户端的一个稳定的调用类(称为环境类)，首先调用这个类能够产生一个具体算法的实例，其次这个调用类，还需要公布一个接口，让客户端调用实现具体功能。</p>
<p>那么做到以上，无论实现多少种双方，客户端的调用都是不变的。控制权都在这个调用类里边，由它来决定到底采用哪种算法。</p>
<p>下面来接着说算法部分。如果需要 <strong>环境类</strong> 提供一个实现具体功能的接口，那么这些算法必然实现了一个公共接口（称为抽象策略类）。才能确保有相同的方法提供出来。然后具体的算法都要实现这个接口。这也就是上面定义中的 <strong>将每一个算法封装起来</strong> 每一个具体的算法称为：具体策略类</p>
<p>不知道这个解释大家清楚定义了没有，如果还不清楚，看类图</p>
<h1 id="类图演示"><a href="#类图演示" class="headerlink" title="类图演示"></a>类图演示</h1><p>策略模式包含的角色如下：</p>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg" alt="image"></p>
<p>这下子是不是很清楚了？策略模式是使用非常广泛的一个设计模式。他很好的提现了：控制反转、依赖注入等思想。有同学说，不想看文字，有本事上代码呀！嗯，我喜欢，新鲜出炉的代码来了</p>
<h1 id="策略模式PHP代码实现"><a href="#策略模式PHP代码实现" class="headerlink" title="策略模式PHP代码实现"></a>策略模式PHP代码实现</h1><p>在整个模式中，Strategy 起着承上启下的作用。我就先来实现它</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，抽象策略类就完成了，他的主要目的就是规范一个必须要实现的方法，环境类依赖这个接口进行编程。</p>
<p>下面接着写算法的实现。还是以支付宝支付、微信支付为例。对于用户来说他要实现的功能是支付。那么支付又有多种选择(多种算法)。但是客户端不需要做出选择，他把这个权利让 环境类 去选择。这样子客户端就简单了。所有的算法需要实现 策略类接口。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成支付宝的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxCharge</span> <span class="keyword">implements</span> <span class="title">ChargeStrategy</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 完成微信的相关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里声明一下，这里为了纯粹的把 策略模式 讲明白，抛开了很多细枝末节，真正的支付中的实现，大家可以去看看<a href="https://github.com/helei112g/payment" target="_blank" rel="external">项目</a>的源代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeContext</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@var</span> ChargeStrategy $charge</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> $charge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">initInstance</span><span class="params">($channel)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($channel == <span class="string">'ali'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> AliCharge;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($chananel == <span class="string">'wx'</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">new</span> WxCharge;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;charge = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;charge)) &#123;</span><br><span class="line">            <span class="keyword">exit</span>(<span class="string">'初始化错误'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">$this</span>-&gt;charge-&gt;charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就基本完成了，而对于客户端来说，就非常简单啦。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户选择的支付方式</span></span><br><span class="line">$channel = trim($_GET[<span class="string">'channel'</span>]);</span><br><span class="line"></span><br><span class="line">$context = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化支付实例</span></span><br><span class="line">$context-&gt;initInstance($channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用功能</span></span><br><span class="line">$context-&gt;charge();</span><br></pre></td></tr></table></figure>
<p>代码写完了，不知道大家有没有感受到好处，这个模式很好的实现了开闭原则。比如说：现在新增加了一个PayPal支付方式。那么只需要添加一个PayPal的策略算法。在ChargeContext中把对应的实例初始化加进去，其他地方都不需要动的。</p>
<h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>最后再说几句，不知道大家注意到没有，在 <code>ChargeContext</code> 这个类中，其实还使用了 <strong>简单工厂</strong> 这个模式。这里想给大家说明的是，其实设计模式只是一些编码的技巧，完全可以自由搭配组合，基本思想就是 <a href="http://blog.csdn.net/hel12he/article/details/51351763" target="_blank" rel="external">设计模式的六大原则</a> </p>
<p>当然，实际编码中也没有必要非要都实现这六大原则。这个也没有什么规范，只能大家多去实践，然后自己约定出一套适合业务的规范就好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP接入支付宝 即时到帐接口]]></title>
      <url>https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>支付宝即时到账接口，简化支付宝本身文档一大堆的配置。让工作变得轻松<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p><strong>特别声明：</strong></p>
<blockquote>
<p>以下文档均针对 payment 2.0 以上版本，并且PHP需要5.5以上(含)。<br>代码中所有编码均使用 utf-8 。</p>
</blockquote>
<p>通过几天的时间，终于把payment 2.0的基本结构搭好了。今天刚完成支付宝 <strong>即时到帐</strong> 接口的开发。赶紧把使用文档给补上。请大家一定仔细查看文档，实在还不行就来问我吧！（我期待你问我，反正我收钱的，哈哈）</p>
<h1 id="即时到帐-接口签约"><a href="#即时到帐-接口签约" class="headerlink" title="即时到帐 接口签约"></a>即时到帐 接口签约</h1><p>在你使用这个接口时，请先确认你是否在支付宝商户中心签约了该接口。</p>
<p><img src="https://helei112g.github.io/images/trade-api.png" alt="image"></p>
<p>在商户中心，看到 <strong>即时到帐（已添加）</strong>，说明你已签约该接口，可正常使用。如果还不知道如何签约，请 <a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.FkBnFB&amp;treeId=62&amp;articleId=104749&amp;docType=1" target="_blank" rel="external">查看支付宝即时到帐签约教程</a></p>
<p>OK！完成签约后，</p>
<p>需要把 <a href="https://github.com/helei112g/payment/tree/paymentv2" target="_blank" rel="external">payment项目导入自己的项目中</a> 安装方法，请参考<a href="http://note.youdao.com/yws/public/redirect/share?id=5f8373d4cdfeb06dbcbe21b942efc53e&amp;type=false" target="_blank" rel="external">Payment项目简介</a>。</p>
<h1 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h1><p>在项目的 <code>examples</code> 文件夹中，我已提供完整的示例。为了便于大家理解，这里对代码再进行说明。</p>
<h2 id="支付宝的配置文件"><a href="#支付宝的配置文件" class="headerlink" title="支付宝的配置文件"></a>支付宝的配置文件</h2><p>在1.x版本中，配置文件被固定写在了sdk中，这种做法太流氓了。为了不继续流氓下去，在2.x版本中，将配置信息独立出来，让大家可以根据自己的实际情况自定义，灵活程度大大增加。</p>
<p>调用时，仅需要提供给我如下的一个数组，至于配置信息写在哪里，完全由你自己决定。</p>
<p>我在示例中，是将配置信息写在 <code>examples/aliconfig.php</code> 中，然后使用 <code>require_once</code> 包含进来。你完全可以写cache中、db中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'partner'</span>   =&gt; <span class="string">'2088xxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'md5_key'</span>   =&gt; <span class="string">'xxxxxxxxxxxxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'rsa_private_key'</span>   =&gt; <span class="string">'./rsa_private_key.pem'</span>,</span><br><span class="line">    <span class="string">"notify_url"</span>	=&gt; <span class="string">'http://test.helei.com/pay-notify.html'</span>,</span><br><span class="line">    <span class="string">"return_url"</span>	=&gt; <span class="string">'http://test.helei.com/return-url.html'</span>,</span><br><span class="line">    <span class="string">"time_expire"</span>	=&gt; <span class="string">'14'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参数介绍</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>partner</td>
<td>合作者身份ID</td>
<td>签约的支付宝账号对应的支付宝唯一用户号。以2088开头的16位纯数字组成。</td>
<td>必须</td>
</tr>
<tr>
<td>md5_key</td>
<td>MD5密钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s1" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>rsa_private_key</td>
<td>RSA私钥</td>
<td><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.qt91b7&amp;treeId=62&amp;articleId=104740&amp;docType=1#s0" target="_blank" rel="external">点击这里</a></td>
<td>必须</td>
</tr>
<tr>
<td>notify_url</td>
<td>服务器异步通知URI</td>
<td>支付宝服务器主动通知商户网站里指定的页面http路径。(建议使用https)</td>
<td>可选</td>
</tr>
<tr>
<td>return_url</td>
<td>页面跳转同步通知页面路径</td>
<td>支付宝处理完请求后，当前页面自动跳转到商户网站里指定页面的http路径。</td>
<td>可选</td>
</tr>
<tr>
<td>time_expire</td>
<td>超时时间</td>
<td>设置未付款交易的超时时间，一旦超时，该笔交易就会自动被关闭。单位默认为分钟</td>
<td>可选</td>
</tr>
</tbody>
</table>
<p><strong>特别说明：</strong></p>
<ul>
<li>如果上述配置文件必须的key的值为空，会抛出 <code>PayException</code> 异常</li>
<li>如果 <code>notify_url</code> 为空，虽然可支付成功，但是客户端将无法收到支付宝的回调结果。</li>
<li>建议采用https协议</li>
</ul>
<h2 id="调用支付"><a href="#调用支付" class="headerlink" title="调用支付"></a>调用支付</h2><p>项目中的示例代码，参见 <code>examples/charge.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  生成订单号 便于测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPayid</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date(<span class="string">'Ymdhis'</span>, time())</span><br><span class="line">            .substr(floor(microtime()*<span class="number">1000</span>),<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            .rand(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单信息</span></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"orderTradeNo"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"totalFee"</span>	=&gt; <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">"clientIp"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'我是即时到帐'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付测试即时到帐接口'</span>,</span><br><span class="line">    <span class="string">"extraCommonParam"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$aliconfig = <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/aliconfig.php'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求alipay</span></span><br><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码就完成了即时到帐的全部调用，下面分步骤来说明下代码含义：</p>
<h3 id="订单信息"><a href="#订单信息" class="headerlink" title="订单信息"></a>订单信息</h3><p>此部分的key部分，必须采用以下值，否则SDK无法识别。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createPayid(); 函数是为了演示方便，随手写的一个生成订单号的函数</span></span><br><span class="line"></span><br><span class="line">$orderData = [</span><br><span class="line">    <span class="string">"order_no"</span>	=&gt; createPayid(),</span><br><span class="line">    <span class="string">"amount"</span>	=&gt; <span class="string">'1'</span>,<span class="comment">// 单位为元</span></span><br><span class="line">    <span class="string">"client_ip"</span>	=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">"subject"</span>	=&gt; <span class="string">'测试支付'</span>,</span><br><span class="line">    <span class="string">"body"</span>	=&gt; <span class="string">'支付接口测试'</span>,</span><br><span class="line">    <span class="string">"extra_param"</span>	=&gt; <span class="string">''</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数名</th>
<th>参数说明</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>order_no</td>
<td>订单号</td>
<td>平台根据规则生成的订单号，最长64位，要在商户数据库中唯一</td>
<td>必须</td>
</tr>
<tr>
<td>amount</td>
<td>交易总金额</td>
<td>该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。</td>
<td>必须</td>
</tr>
<tr>
<td>client_ip</td>
<td>客户端IP</td>
<td>用户在创建交易时，该用户当前所使用机器的IP。</td>
<td>必须</td>
</tr>
<tr>
<td>subject</td>
<td>商品名称</td>
<td>商品的标题/交易标题/订单标题/订单关键字等。该参数最长为128个汉字。</td>
<td>必须</td>
</tr>
<tr>
<td>body</td>
<td>商品描述</td>
<td>对一笔交易的具体描述信息。如果是多种商品，请将商品描述字符串累加传给body。</td>
<td>必须</td>
</tr>
<tr>
<td>extra_param</td>
<td>公用回传参数</td>
<td>如果用户请求时传递了该参数，则返回给商户时会回传该参数。</td>
<td>可选</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="签名数据"><a href="#签名数据" class="headerlink" title="签名数据"></a>签名数据</h3><p>以下是真正实现数据签名的地方，返回的数据可直接用于发起支付宝支付。大家可以对比下支付宝自身信息，是不是已经大大简化了？<br>当然简化带来的另外一个意思就是：放弃了很多我们正常情况下用不到的功能，比如：花呗分期</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化支付环境类，进行支付创建</span></span><br><span class="line">$charge = <span class="keyword">new</span> ChargeContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $charge-&gt;initCharge(Config::ALI_CHANNEL_WEB, $aliconfig);</span><br><span class="line">    $url = $charge-&gt;charge($payData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PayException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;errorMessage();<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对于调用者，仅仅需要知道 <code>ChargeContext</code> 这一个类，这里使用了 <strong>策略模式 + 简单工厂模式</strong> 两种方法来进行调用的简化。这种方式也非常方便后期进行扩展，对于客户端与复杂的逻辑进行了隔离。</p>
<h3 id="跳转支付宝"><a href="#跳转支付宝" class="headerlink" title="跳转支付宝"></a>跳转支付宝</h3><p>通过上一步返回的是请求支付宝的url。由于在页面上可能需要通过js调用支付宝或者还有其他逻辑，因为我并没有直接重定向到支付宝，而把控制权交到了客户端手中。</p>
<p>以下代码，示例的是简单的利用返回的url，重定向到支付宝，完成支付。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Location:&#123;$url&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>本次支付宝的即时到帐接口到这里就完成了调用。下一节把回调通知部分完成，这样一个基本的支付流程就完成了。</p>
<h1 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h1><blockquote>
<p>如果需要协助集成到项目，可付费获得我的服务！</p>
</blockquote>
<ul>
<li><p>邮箱: <strong>dayugog@gmail.com</strong></p>
</li>
<li><p>对我有用，我要打赏：</p>
</li>
</ul>
<p><img src="https://helei112g.github.io/images/ali-qr.png" alt="image"></p>
<blockquote>
<p><a href="https://helei112g.github.io/categories/payment/">项目文档首页</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝、微信支付接入集成]]></title>
      <url>https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E3%80%81%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<p>没有摘要，请看正文<br><a id="more"></a></p>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 项目2.x版本</a> </p>
<p>从开始写代码以来，一直就与支付打交道。终于到今天，我忍无可忍啦！每次都要重新写，重新调（主要换工作后，不能把前东家的代码给拷贝走）。好吧，写一份放到github上，以后啥时候用都有了，还方便做外包（哈哈哈……）</p>
<p>之前看了 ping++ 集成的各路支付接口，觉得挺爽的，但是要收费，而且公司也不放心，怕什么时候 ping++ 坚持不住了，那到时候怎么办？我倒是觉得可能大部分公司坚持不住了，ping++ 还在呢！ 因此不自量力的自己也来集成一个吧！</p>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>说明：</strong></p>
<ul>
<li>PHP 5.5 以上版本，包含5.5</li>
<li>采用PSR-4标准编码，可通过composer实现自动加载。</li>
<li>如果项目无法使用composer，请通过包含项目中的 <code>autoload.php</code> 来实现自动加载</li>
<li>客户端传入的参数均使用 <strong>下划线风格</strong></li>
</ul>
<h2 id="composer安装Payment"><a href="#composer安装Payment" class="headerlink" title="composer安装Payment"></a>composer安装Payment</h2><p>如果你励志要做php，强烈建议你学习下composer。</p>
<p><em>composer学习地址： <a href="http://www.phpcomposer.com/" target="_blank" rel="external">http://www.phpcomposer.com/</a></em></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装时请自行指定版本。否则将安装稳定版，当前稳定版是1.x</span></span><br><span class="line">composer <span class="keyword">require</span> riverslei/payment</span><br></pre></td></tr></table></figure>
<p>通过composer安装后，无需任何操作，可在项目中直接使用。</p>
<h2 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h2><p>当然如果由于历史原因（如果没有历史原因，强烈推荐composer安装，方便后续更新），无法通过composer安装，那么请自行下载（下载地址见下方 功能介绍），并在使用时，包含 <code>autoload.php</code> 文件。这种方式就不过多介绍了。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>说这么多废话没什么卵用，还是先介绍下本SDK支持的支付接口</p>
<ol>
<li>支付宝支付<ul>
<li><a href="https://helei112g.github.io/2016/07/18/%E6%94%AF%E4%BB%98%E5%AE%9D%EF%BC%9A%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/">支付宝即时到帐</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">支付宝异步通知回调</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">支付宝手机网站</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E3%80%81%E7%A7%BB%E5%8A%A8%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/">支付宝移动支付</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝有密退款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%9C%89%E5%AF%86%E6%89%B9%E9%87%8F%E8%BD%AC%E6%AC%BE%E6%8E%A5%E5%8F%A3/">支付宝有密批量付款</a></li>
<li><a href="https://helei112g.github.io/2016/08/03/PHP%E6%8E%A5%E5%85%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E5%8D%95%E7%AC%94%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/">支付宝订单查询</a></li>
</ul>
</li>
</ol>
<ol>
<li>微信支付    <ul>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%EF%BC%9AAPP%E6%94%AF%E4%BB%98%E3%80%81%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E3%80%81%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/">微信公众号支付\微信扫码支付\APP支付 接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/10/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E3%80%81%E9%80%80%E6%AC%BE%E8%AE%A2%E5%8D%95%E3%80%81%E8%BD%AC%E6%AC%BE%E8%AE%A2%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2/">订单查询接口/退款订单查询接口/企业付款查询接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%8F%A3/">微信退款接口</a></li>
<li><a href="https://helei112g.github.io/2016/07/29/%E6%94%AF%E4%BB%98%E7%9A%84%E5%9B%9E%E8%B0%83%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/">微信异步通知回调接口</a></li>
<li><a href="https://helei112g.github.io/2016/08/16/PHP%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E4%BB%98%E6%AC%BE%E5%8A%9F%E8%83%BD/">企业付款接口</a></li>
</ul>
</li>
</ol>
<p><a href="https://github.com/helei112g/payment" target="_blank" rel="external">payment 2.x版本</a></p>
<p>当然有很多朋友问我支不支持paypal 银联等等。我也想呀，可惜这个得慢慢来。我这基础功能还搞完呢！哈哈，当然也欢迎大家push代码给我</p>
<h1 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h1><p>本来我想有完整的示例代码，大家应该在使用中不会遇到什么问题，但是还有有朋友遇到诸多问题。那么有关于项目本身的bug或建议，大家可以通过以下方式联系我：</p>
<ul>
<li>邮箱: <strong>dayugog@gmail.com</strong></li>
<li>微信：<strong>helei543345</strong></li>
</ul>
<blockquote>
<p>此外如果需要协助集成到项目，可付费获得我的服务！</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[1.APP后端开发系列：登陆系统设计中的注意问题]]></title>
      <url>https://helei112g.github.io/2016/07/12/1-APP%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>自从接触到app开发以来，遇到很多问题，一直都是一路走，一路解决。希望这些文字能够让大家少走些弯路。<br><a id="more"></a></p>
<p>想写这个系列很久了，因为之前做这个东西花费了大量的精力，有必要分享出来与大家共享。以前也写了一些关于 <a href="http://blog.csdn.net/hel12he/article/details/47721209" target="_blank" rel="external">APP后端开发的系列文章</a> 由于当初功力不够，很多问题描述不清楚或者解决方案过于复杂、不严谨等。</p>
<p>这一次查了很多资料，问了很多相关人士。准备再结合自己实际工作中的问题再次进行一些补充。就先从登陆的设计开始吧！</p>
<h1 id="越想越糊涂"><a href="#越想越糊涂" class="headerlink" title="越想越糊涂"></a>越想越糊涂</h1><p>之前再做这一部分的时候，总想着复杂的技术，说出去多调炸天呀。一般来说登陆的流程是：</p>
<p><img src="https://helei112g.github.io/images/login-flow.png" alt="image"></p>
<p>当时对于安全性过度痴迷，确走偏了道路。首先提交的时候爬信息被人劫持，因此客户端在上传时，进行AES加密，服务端解密出结果。服务端返回的信息也会AES加密，然后客户端解密。</p>
<p>然后这里又带来另外一个问题：加密信息放在了客户端，那么一但客户端被反编译，hacker拿到秘钥，那么对于服务端来说加密就没有任何意义了。又为了不在客户端保存这么敏感的信息，就像秘钥由服务端下发。这样子服务端可随时对秘钥进行变更。</p>
<p>到这里又带来了一个新的问题，感脚一切又回到了起点：下发秘钥要走http，那么依然可能被人劫持。这时候该是加密还是怎么弄呢？如果加密，客户端又放了一个秘钥过去。那这个秘钥依然可能被人反编译。不能再从服务端获取这个秘钥吧？为了确保上个秘钥的安全，生产下一个秘钥……</p>
<p>当时就是陷入了这样的死循环，不可自拔。现在想想真是too young too simple!</p>
<h1 id="简单、有效"><a href="#简单、有效" class="headerlink" title="简单、有效"></a>简单、有效</h1><p>首先在这里还是先说一下：如果你的产品刚刚起步，不要过于纠结性能、安全</p>
<p>先说性能：你的产品才推出的时候，冷启动的用户数一般来说不会超过1000人（这已经是很不得了的冷启动人数了）。然后你的并发也不会超过100。这种级别的访问，相信机器硬件就可以帮助你解决。如果你的条件远远超出以上规模，那么你的实力绝对足以应付即将发生的事情。<br>谈谈安全：安全这个事情，从一开始就要考虑，但是不能过于纠结（我之后可以讲讲我在做短信验证码这一部分的遇到的一个经理）。过早介入，会导致系统开发速度降低，过早做了一些不需要的事情（hacker来搞你也是需要成本的，在你没价值的时候，没人愿意来搞你）。所以早期应该重视开发成本，抓紧时间，早日上线。</p>
<p>另外，安全与性能有时候也是鱼与熊掌。</p>
<h1 id="演化之路"><a href="#演化之路" class="headerlink" title="演化之路"></a>演化之路</h1><p>这一部分会有一些代码与图来进行说明。在安全方面逐步演进。前面说前期开发只要快就好，但是这里也要注意一个问题，就是后续升级能够弥补前面的错，要给未来升级留下余地。因为否则你的系统始终留下了一个隐患。</p>
<h2 id="实现功能就好"><a href="#实现功能就好" class="headerlink" title="实现功能就好"></a>实现功能就好</h2><p>这是最开始的阶段，重点考虑功能实现。用户提交username + pwd 服务端验证通过后，返回一个令牌token。</p>
<p>这里需要注意的几个部分是要为未来的升级做好准备。我经常遇到的几个初期设计是：</p>
<blockquote>
<ol>
<li>验证通过后，把用户uid+username+salt等md5后，作为token返回到客户端。</li>
<li>对token加入时间戳，过期后客户端重新提交username + pwd验证后再发一个token到客户端</li>
<li>服务端生成一个token后下发到客户端，客户端按照约定的规则加密后请求服务端。</li>
</ol>
</blockquote>
<p>先说第一种带来的问题：生成的token永久不变，那么别人获取到一个token就可以无限制的进行请求。直到你关闭了这个接口为止。为后续安全设计增加了成本。</p>
<p>第二种问题就有点老火了，虽然看似token只在一定时间范围内有效了，但是其实更不安全了。首先客户端需要保存用户的用户名与密码，如果用户手机平时不注重安全，很容易被人窃取。</p>
<p>第三种设计方案，这是我原先干过的一件事，是这三种方案中最垃圾的设计。得出的教训就是：绝不能把任何加密的事情交给客户端。这样子灵活性大打折扣。举例：还是升级接口了，现在本来token生成只是服务端的事情，服务端随时可动态改变规则，现在由于客户端也参与进来了，这事儿就麻烦了，你一改，客户端也要跟着改。没有任何灵活性可言。切记：客户端就接收，然后转发回服务端就好了。别再客户端进行加密！！！</p>
<p>经过这些坑的历练，参考oauth2.0，我现在采用以下方案：</p>
<p>用户提交username + pwd后，服务端返回以下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>access_token</strong> 是用来进行访问的接口的，<strong>expires_in</strong> 是他的过期时间，到达过期时间后，需要用 <strong>refresh_token</strong>  来请求服务端刷新 <strong>access_token</strong>。</p>
<p>这里几个重点是：<strong>refresh_token</strong> 仅能使用一次，使用一次后，将被废弃。另外这个 <strong>access_token</strong> 只在 <strong>expires_in</strong> 有效期内有效。</p>
<p><strong>注意：</strong> 这里的 expires_in 仅返回秒数就好了。别返回时间戳。因为各个平台计算s的时间戳，不一致，这样子做更方便处理。</p>
<h2 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h2><p>上面我们简单实现了功能，现在app的流量上来了，有些功能也很复杂，如果某个接口访问量太大，会导致服务器崩溃，需要分别对每个接口每次访问设置频率（也可以统一设置每个接口访问的频率）。</p>
<p>一般我的做法是加入一个中间件。每一个接口的访问频率做好一个对应的配置文件。比如：</p>
<ul>
<li>a接口 5s内可访问1次</li>
<li>b接口 10s内可访问1次（可能非常耗时，如果同时过多请求会导致服务器崩溃）</li>
</ul>
<p>那么就把 <strong>access_token</strong> 与这些关联起来。这里需要用到redis。当用户A进来访问了 a接口 那么设置这个token 5s内不能再次访问。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($redis-&gt;get($key)) &#123;</span><br><span class="line">    <span class="comment">// 无法访问，还未到时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置频率控制key</span></span><br><span class="line">$redis-&gt;setex($key, $expires, $value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问接口</span></span><br></pre></td></tr></table></figure>
<p>这里需要考虑几个问题：</p>
<p>设置的访问时间要合理。举例：客户端一般启动的时候会请求多个接口，那么当这些请求到达后，服务端可能拒绝其中一部分访问（因为在频率控制内）</p>
<p>一般来说不需要对所有的接口都进行频率控制，仅仅针对重要的内容以及性能上有要求的接口进行频率控制。</p>
<h2 id="账号安全考虑"><a href="#账号安全考虑" class="headerlink" title="账号安全考虑"></a>账号安全考虑</h2><p>现在又进一步了，需要考虑用户账号安全的问题。比如：QQ，有时候会提醒我们你的账号在香港登陆了。如果不是自己所为，赶快修改密码之类的。</p>
<p>实现这个功能，你需要记录每次登陆、启动时每个token对应的ip地址。如果ip地址与上次的ip不在同一个范围（这个规则由自己定，因为有的运营商ip经常变化，比如：长城）。就提醒用户是不是他自己所为，如果不是，就赶快修改密码。</p>
<p>现在很多app在开发之初，都是可以多个设备同时登陆。这样带来的安全问题也很多。如果要做成单个设备登陆，需要每个token对应一个deviceToken。</p>
<p>这一部分就不继续深入讨论下去了。</p>
<h2 id="防DNS劫持"><a href="#防DNS劫持" class="headerlink" title="防DNS劫持"></a>防DNS劫持</h2><p>安全工作做得再好，如果有人能够获得大量合法用户的token，来请求你的借口，你也无法识别，因为从行为来看，这一切都是合法用户再进行。</p>
<p>以前为了防止别人获取到合法的信息，我才弄出了很狗血的客户端加密方法。导致后期升级的时候，诸多问题。这个东西其实很简单，使用https来进行请求（可以个人关键接口使用）</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>才开始做app服务端的时候，总想着token的设计。怎么才能生成一个好的token呢？现在想想真不知道当初怎么想的。</p>
<h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>首先搞明白这个token的作用就是一个令牌，用来标记一个用户的身份。那么首先他要唯一。其次他从客户端上传后，服务端能够验证这个token是由服务端生成的。</p>
<p>所以token生成只要满足以上目的，你随意就好了。当然别把敏感信息暴露出去了。</p>
<p>常用的一种生成方式：</p>
<ol>
<li>该用户的uid，如：8888</li>
<li>该用户的口令，如： 123123</li>
<li>用户对应的salt，如：abcd</li>
<li>过期时间戳，如：1468293948</li>
</ol>
<p>把上面几部分拼接起来：888:123123:abcd:1468293948</p>
<p>token = md5(‘888:123123:abcd:1468293948’);</p>
<h2 id="token的验证"><a href="#token的验证" class="headerlink" title="token的验证"></a>token的验证</h2><p>对于token也有两种方法进行验证。一是：服务端生成后，将token保存起来（redis或者mysql中）。客户端穿上来之后，检查是否有该token，如果有取出对应的信息，比如uid，验证是否匹配。</p>
<p>另一种方法是：根据上传的uid，生成对应的token，然后进行比较token结果是否一致（要保障该算法如果给定的值一定，结果必须唯一。常用md5）。</p>
<p>对于个人而言更倾向于第二种方案。第一种方案效率更高（可使用redis存储这个token），但是如果redis一但雪崩，就会造成所有用户登录失效，一定时间内不可登陆。初期越简单、越可靠更好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一部分没有太多代码，主要是思路。还有涉及到H5的登陆问题也没有说到。下篇文章会把APP中登陆后，如果搞定H5登陆的问题进行阐述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php设计模式：状态模式的使用场景]]></title>
      <url>https://helei112g.github.io/2016/06/28/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>最初为了减少代码中的逻辑判断，使用了该模式，不过大家在实际中还是需要权衡，太多的类未必就比if{…}else{…}更好。</p>
<a id="more"></a>
<p>在这儿给大家说点事儿。我的博客搬家到github主页上了。<a href="https://helei112g.github.io">我的博客</a>。以后首发都在github上了。csdn也会继续更新。可能就是稍微慢一下。</p>
<p>另外最近搞了一个支付的开源项目。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">这是项目地址</a>  目前已经支持：</p>
<ul>
<li>支付宝的 即时到帐、移动支付、加密退款接口。</li>
<li>微信的目前已经支持：app支付、扫码支付、H5支付</li>
</ul>
<p>项目还存在些bug，正在不断结合公司业务进行修改。后期可能会支持的越来越全面。</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>废话不多说了，回到本文主题： 状态模式</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>说实话，这定义真JB不是怎么读的懂。不过咱要试着去理解其中的精髓。谁让咱们有颗向上的心呢？</p>
<p>一句句来。</p>
<p>先说这一句： <strong>允许一个对象在其内部状态改变时改变它的行为</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($state)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是好人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我要当坏人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 其他状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'爱好和平!'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下我要开始自己的理解了，这个理解不一定是上面定义的本意，但是绝对讲人话，有帮助，可实战。</p>
<p>如果 <code>state</code> 传入的值不同，则会得到不同的行为。那么这就是我理解的这一句话的意思。再说白话一点，根据不同的条件，执行不同的逻辑。</p>
<p><strong>对象看起来似乎修改了它的类</strong>  这一句更扯淡，真不知道这些人怎么想的，就不能说的通俗些？我觉得嘛，这个概念能懂就懂，不懂呢，你就这么办：那就是对于每一个条件中的逻辑，移入到不同的类中，这些类要实现一个统一的接口。还不懂？上代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface State()</span><br><span class="line">&#123;</span><br><span class="line">    // 注意这里的Context 我在后面会讲到。不等同于上面的 Context 类哦</span><br><span class="line">    public function handle(Context $context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态A</span><br><span class="line">class StateA implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 1) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateB());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态B</span><br><span class="line">class StateB implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 2) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateC());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态C</span><br><span class="line">class StateC implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果还有其他状态，则继续往下走。如果没有，就在次终止程序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 新的Context类的实现</span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    private $state;// 用来保存 State 对象</span><br><span class="line">    </span><br><span class="line">    public function setState(State $state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state-&gt;handle($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上就已经演示了 <strong>状态模式</strong> 。有看官急了，写的什么狗屎？怎么用，哪儿可以用？别急，等我把这个逼装完。</p>
<h2 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h2><p>继续装逼，上类图。</p>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg" alt="类图"></p>
<p>从这个图中可以看出，纯种的状态模式，包括了以下三个角色：</p>
<ul>
<li>Context: 环境类。它呢需要在代码中传给具体的 State 类，这样State类才能改变它。记得这句 <strong>对象看起来似乎修改了它的类</strong> 吗？就着这句话再去理解下这个类。他保存有当前的状态。</li>
<li>State: 抽象的状态接口 。让具体的状态都要实现这个接口，Context依赖接口进行编程。</li>
<li>ConcreteState： 具体的状态类。专门用于处理某一个状态，如果处理不了就转发出去。</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>上面讲那么多，不能真刀真枪的用到项目中，都是耍流氓。在我们的项目中其实有特别多的地方可以用到状态模式。</p>
<ul>
<li>如果项目中存在太多的 <code>if {...} elseif {...} else {...}</code> 。那么你应该考虑状态模式。<em>我觉得这个是重点考虑对象</em></li>
<li>如果每个状态中处理的业务逻辑特别复杂·那么建议考虑这种方式。</li>
<li>最后一点，如果代码中的状态相对固定。比如一个电商中购买商品的流程：未支付、已过期、待发货（已支付）、已发货、已收货。那么这种状态基本上定下来不会有太大变化，状态发生在内部中，顺序固定，不需要客户端进行处理。</li>
</ul>
<p>以上三种情况是我建议的方式。如果大家还有总结的经验，欢迎分享。</p>
<p>这里有个问题，待我写完 <strong>职责链模式</strong> 之后再来分享。因为这二者有相当多的共同之处。大家一定认真阅读我写的 <strong>使用场景</strong> 的最后一点。</p>
]]></content>
    </entry>
    
  
  
</search>
