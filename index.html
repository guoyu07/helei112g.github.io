<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>大愚的博客｜与你把酒言诗</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="大愚的博客｜与你把酒言诗">
<meta property="og:url" content="https://helei112g.github.io/index.html">
<meta property="og:site_name" content="大愚的博客｜与你把酒言诗">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大愚的博客｜与你把酒言诗">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="大愚的博客｜与你把酒言诗" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-79844617-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-1-APP后端开发系列：登陆系统设计中的注意问题" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/1-APP后端开发系列：登陆系统设计中的注意问题/">1.APP后端开发系列：登陆系统设计中的注意问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/07/12/1-APP后端开发系列：登陆系统设计中的注意问题/" class="article-date">
  <time datetime="2016-07-12T11:18:18.000Z" itemprop="datePublished">2016-07-12</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>想写这个系列很久了，因为之前做这个东西花费了大量的精力，有必要分享出来与大家共享。以前也写了一些关于 <a href="http://blog.csdn.net/hel12he/article/details/47721209" target="_blank" rel="external">APP后端开发的系列文章</a> 由于当初功力不够，很多问题描述不清楚或者解决方案过于复杂、不严谨等。</p>
<p>这一次查了很多资料，问了很多相关人士。准备再结合自己实际工作中的问题再次进行一些补充。就先从登陆的设计开始吧！</p>
<h1 id="越想越糊涂"><a href="#越想越糊涂" class="headerlink" title="越想越糊涂"></a>越想越糊涂</h1><p>之前再做这一部分的时候，总想着复杂的技术，说出去多调炸天呀。一般来说登陆的流程是：</p>
<p><img src="http://note.youdao.com/yws/public/resource/82ee87138ba987799b398e12b6c79c95/9048DB7675454DA6B904A2315E97B9C7" alt="image"></p>
<p>当时对于安全性过度痴迷，确走偏了道路。首先提交的时候爬信息被人劫持，因此客户端在上传时，进行AES加密，服务端解密出结果。服务端返回的信息也会AES加密，然后客户端解密。</p>
<p>然后这里又带来另外一个问题：加密信息放在了客户端，那么一但客户端被反编译，hacker拿到秘钥，那么对于服务端来说加密就没有任何意义了。又为了不在客户端保存这么敏感的信息，就像秘钥由服务端下发。这样子服务端可随时对秘钥进行变更。</p>
<p>到这里又带来了一个新的问题，感脚一切又回到了起点：下发秘钥要走http，那么依然可能被人劫持。这时候该是加密还是怎么弄呢？如果加密，客户端又放了一个秘钥过去。那这个秘钥依然可能被人反编译。不能再从服务端获取这个秘钥吧？为了确保上个秘钥的安全，生产下一个秘钥……</p>
<p>当时就是陷入了这样的死循环，不可自拔。现在想想真是too young too simple!</p>
<h1 id="简单、有效"><a href="#简单、有效" class="headerlink" title="简单、有效"></a>简单、有效</h1><p>首先在这里还是先说一下：如果你的产品刚刚起步，不要过于纠结性能、安全</p>
<p>先说性能：你的产品才推出的时候，冷启动的用户数一般来说不会超过1000人（这已经是很不得了的冷启动人数了）。然后你的并发也不会超过100。这种级别的访问，相信机器硬件就可以帮助你解决。如果你的条件远远超出以上规模，那么你的实力绝对足以应付即将发生的事情。<br>谈谈安全：安全这个事情，从一开始就要考虑，但是不能过于纠结（我之后可以讲讲我在做短信验证码这一部分的遇到的一个经理）。过早介入，会导致系统开发速度降低，过早做了一些不需要的事情（hacker来搞你也是需要成本的，在你没价值的时候，没人愿意来搞你）。所以早期应该重视开发成本，抓紧时间，早日上线。</p>
<p>另外，安全与性能有时候也是鱼与熊掌。</p>
<h1 id="演化之路"><a href="#演化之路" class="headerlink" title="演化之路"></a>演化之路</h1><p>这一部分会有一些代码与图来进行说明。在安全方面逐步演进。前面说前期开发只要快就好，但是这里也要注意一个问题，就是后续升级能够弥补前面的错，要给未来升级留下余地。因为否则你的系统始终留下了一个隐患。</p>
<h2 id="实现功能就好"><a href="#实现功能就好" class="headerlink" title="实现功能就好"></a>实现功能就好</h2><p>这是最开始的阶段，重点考虑功能实现。用户提交username + pwd 服务端验证通过后，返回一个令牌token。</p>
<p>这里需要注意的几个部分是要为未来的升级做好准备。我经常遇到的几个初期设计是：</p>
<blockquote>
<ol>
<li>验证通过后，把用户uid+username+salt等md5后，作为token返回到客户端。</li>
<li>对token加入时间戳，过期后客户端重新提交username + pwd验证后再发一个token到客户端</li>
<li>服务端生成一个token后下发到客户端，客户端按照约定的规则加密后请求服务端。</li>
</ol>
</blockquote>
<p>先说第一种带来的问题：生成的token永久不变，那么别人获取到一个token就可以无限制的进行请求。直到你关闭了这个接口为止。为后续安全设计增加了成本。</p>
<p>第二种问题就有点老火了，虽然看似token只在一定时间范围内有效了，但是其实更不安全了。首先客户端需要保存用户的用户名与密码，如果用户手机平时不注重安全，很容易被人窃取。</p>
<p>第三种设计方案，这是我原先干过的一件事，是这三种方案中最垃圾的设计。得出的教训就是：绝不能把任何加密的事情交给客户端。这样子灵活性大打折扣。举例：还是升级接口了，现在本来token生成只是服务端的事情，服务端随时可动态改变规则，现在由于客户端也参与进来了，这事儿就麻烦了，你一改，客户端也要跟着改。没有任何灵活性可言。切记：客户端就接收，然后转发回服务端就好了。别再客户端进行加密！！！</p>
<p>经过这些坑的历练，参考oauth2.0，我现在采用以下方案：</p>
<p>用户提交username + pwd后，服务端返回以下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">    <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>access_token</strong> 是用来进行访问的接口的，<strong>expires_in</strong> 是他的过期时间，到达过期时间后，需要用 <strong>refresh_token</strong>  来请求服务端刷新 <strong>access_token</strong>。</p>
<p>这里几个重点是：<strong>refresh_token</strong> 仅能使用一次，使用一次后，将被废弃。另外这个 <strong>access_token</strong> 只在 <strong>expires_in</strong> 有效期内有效。</p>
<p><strong>注意：</strong> 这里的 expires_in 仅返回秒数就好了。别返回时间戳。因为各个平台计算s的时间戳，不一致，这样子做更方便处理。</p>
<h2 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h2><p>上面我们简单实现了功能，现在app的流量上来了，有些功能也很复杂，如果某个接口访问量太大，会导致服务器崩溃，需要分别对每个接口每次访问设置频率（也可以统一设置每个接口访问的频率）。</p>
<p>一般我的做法是加入一个中间件。每一个接口的访问频率做好一个对应的配置文件。比如：</p>
<ul>
<li>a接口 5s内可访问1次</li>
<li>b接口 10s内可访问1次（可能非常耗时，如果同时过多请求会导致服务器崩溃）</li>
</ul>
<p>那么就把 <strong>access_token</strong> 与这些关联起来。这里需要用到redis。当用户A进来访问了 a接口 那么设置这个token 5s内不能再次访问。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($redis-&gt;get($key)) &#123;</span><br><span class="line">    <span class="comment">// 无法访问，还未到时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置频率控制key</span></span><br><span class="line">$redis-&gt;setex($key, $expires, $value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问接口</span></span><br></pre></td></tr></table></figure>
<p>这里需要考虑几个问题：</p>
<p>设置的访问时间要合理。举例：客户端一般启动的时候会请求多个接口，那么当这些请求到达后，服务端可能拒绝其中一部分访问（因为在频率控制内）</p>
<p>一般来说不需要对所有的接口都进行频率控制，仅仅针对重要的内容以及性能上有要求的接口进行频率控制。</p>
<h2 id="账号安全考虑"><a href="#账号安全考虑" class="headerlink" title="账号安全考虑"></a>账号安全考虑</h2><p>现在又进一步了，需要考虑用户账号安全的问题。比如：QQ，有时候会提醒我们你的账号在香港登陆了。如果不是自己所为，赶快修改密码之类的。</p>
<p>实现这个功能，你需要记录每次登陆、启动时每个token对应的ip地址。如果ip地址与上次的ip不在同一个范围（这个规则由自己定，因为有的运营商ip经常变化，比如：长城）。就提醒用户是不是他自己所为，如果不是，就赶快修改密码。</p>
<p>现在很多app在开发之初，都是可以多个设备同时登陆。这样带来的安全问题也很多。如果要做成单个设备登陆，需要每个token对应一个deviceToken。</p>
<p>这一部分就不继续深入讨论下去了。</p>
<h2 id="防DNS劫持"><a href="#防DNS劫持" class="headerlink" title="防DNS劫持"></a>防DNS劫持</h2><p>安全工作做得再好，如果有人能够获得大量合法用户的token，来请求你的借口，你也无法识别，因为从行为来看，这一切都是合法用户再进行。</p>
<p>以前为了防止别人获取到合法的信息，我才弄出了很狗血的客户端加密方法。导致后期升级的时候，诸多问题。这个东西其实很简单，使用https来进行请求（可以个人关键接口使用）</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>才开始做app服务端的时候，总想着token的设计。怎么才能生成一个好的token呢？现在想想真不知道当初怎么想的。</p>
<h2 id="token的生成"><a href="#token的生成" class="headerlink" title="token的生成"></a>token的生成</h2><p>首先搞明白这个token的作用就是一个令牌，用来标记一个用户的身份。那么首先他要唯一。其次他从客户端上传后，服务端能够验证这个token是由服务端生成的。</p>
<p>所以token生成只要满足以上目的，你随意就好了。当然别把敏感信息暴露出去了。</p>
<p>常用的一种生成方式：</p>
<ol>
<li>该用户的uid，如：8888</li>
<li>该用户的口令，如： 123123</li>
<li>用户对应的salt，如：abcd</li>
<li>过期时间戳，如：1468293948</li>
</ol>
<p>把上面几部分拼接起来：888:123123:abcd:1468293948</p>
<p>token = md5(‘888:123123:abcd:1468293948’);</p>
<h2 id="token的验证"><a href="#token的验证" class="headerlink" title="token的验证"></a>token的验证</h2><p>对于token也有两种方法进行验证。一是：服务端生成后，将token保存起来（redis或者mysql中）。客户端穿上来之后，检查是否有该token，如果有取出对应的信息，比如uid，验证是否匹配。</p>
<p>另一种方法是：根据上传的uid，生成对应的token，然后进行比较token结果是否一致（要保障该算法如果给定的值一定，结果必须唯一。常用md5）。</p>
<p>对于个人而言更倾向于第二种方案。第一种方案效率更高（可使用redis存储这个token），但是如果redis一但雪崩，就会造成所有用户登录失效，一定时间内不可登陆。初期越简单、越可靠更好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一部分没有太多代码，主要是思路。还有涉及到H5的登陆问题也没有说到。下篇文章会把APP中登陆后，如果搞定H5登陆的问题进行阐述。</p>

      

      
        
    </div>
  </div>
  
</article>


  
    <article id="post-php设计模式：状态模式的使用场景" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/28/php设计模式：状态模式的使用场景/">php设计模式：状态模式的使用场景</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/28/php设计模式：状态模式的使用场景/" class="article-date">
  <time datetime="2016-06-28T15:48:44.000Z" itemprop="datePublished">2016-06-28</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这儿给大家说点事儿。我的博客搬家到github主页上了。<a href="https://helei112g.github.io">我的博客</a>。以后首发都在github上了。csdn也会继续更新。可能就是稍微慢一下。</p>
<p>另外最近搞了一个支付的开源项目。<a href="https://github.com/helei112g/payment" target="_blank" rel="external">这是项目地址</a>  目前已经支持：</p>
<ul>
<li>支付宝的 即时到帐、移动支付、加密退款接口。</li>
<li>微信的目前已经支持：app支付、扫码支付、H5支付</li>
</ul>
<p>项目还存在些bug，正在不断结合公司业务进行修改。后期可能会支持的越来越全面。</p>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>废话不多说了，回到本文主题： 状态模式</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>说实话，这定义真JB不是怎么读的懂。不过咱要试着去理解其中的精髓。谁让咱们有颗向上的心呢？</p>
<p>一句句来。</p>
<p>先说这一句： <strong>允许一个对象在其内部状态改变时改变它的行为</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($state)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我是好人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;state == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'我要当坏人'</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 其他状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'爱好和平!'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下我要开始自己的理解了，这个理解不一定是上面定义的本意，但是绝对讲人话，有帮助，可实战。</p>
<p>如果 <code>state</code> 传入的值不同，则会得到不同的行为。那么这就是我理解的这一句话的意思。再说白话一点，根据不同的条件，执行不同的逻辑。</p>
<p><strong>对象看起来似乎修改了它的类</strong>  这一句更扯淡，真不知道这些人怎么想的，就不能说的通俗些？我觉得嘛，这个概念能懂就懂，不懂呢，你就这么办：那就是对于每一个条件中的逻辑，移入到不同的类中，这些类要实现一个统一的接口。还不懂？上代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface State()</span><br><span class="line">&#123;</span><br><span class="line">    // 注意这里的Context 我在后面会讲到。不等同于上面的 Context 类哦</span><br><span class="line">    public function handle(Context $context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态A</span><br><span class="line">class StateA implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 1) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateB());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态B</span><br><span class="line">class StateB implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($context-&gt;term = 2) &#123;</span><br><span class="line">            // 处理逻辑，并终止程序</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $context.setState(new StateC());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 状态C</span><br><span class="line">class StateC implements State</span><br><span class="line">&#123;</span><br><span class="line">    public function handle(Context $context)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果还有其他状态，则继续往下走。如果没有，就在次终止程序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 新的Context类的实现</span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">    private $state;// 用来保存 State 对象</span><br><span class="line">    </span><br><span class="line">    public function setState(State $state)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state = $state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function request()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;state-&gt;handle($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上就已经演示了 <strong>状态模式</strong> 。有看官急了，写的什么狗屎？怎么用，哪儿可以用？别急，等我把这个逼装完。</p>
<h2 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h2><p>继续装逼，上类图。</p>
<p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg" alt="类图"></p>
<p>从这个图中可以看出，纯种的状态模式，包括了以下三个角色：</p>
<ul>
<li>Context: 环境类。它呢需要在代码中传给具体的 State 类，这样State类才能改变它。记得这句 <strong>对象看起来似乎修改了它的类</strong> 吗？就着这句话再去理解下这个类。他保存有当前的状态。</li>
<li>State: 抽象的状态接口 。让具体的状态都要实现这个接口，Context依赖接口进行编程。</li>
<li>ConcreteState： 具体的状态类。专门用于处理某一个状态，如果处理不了就转发出去。</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>上面讲那么多，不能真刀真枪的用到项目中，都是耍流氓。在我们的项目中其实有特别多的地方可以用到状态模式。</p>
<ul>
<li>如果项目中存在太多的 <code>if {...} elseif {...} else {...}</code> 。那么你应该考虑状态模式。<em>我觉得这个是重点考虑对象</em></li>
<li>如果每个状态中处理的业务逻辑特别复杂·那么建议考虑这种方式。</li>
<li>最后一点，如果代码中的状态相对固定。比如一个电商中购买商品的流程：未支付、已过期、待发货（已支付）、已发货、已收货。那么这种状态基本上定下来不会有太大变化，状态发生在内部中，顺序固定，不需要客户端进行处理。</li>
</ul>
<p>以上三种情况是我建议的方式。如果大家还有总结的经验，欢迎分享。</p>
<p>这里有个问题，待我写完 <strong>职责链模式</strong> 之后再来分享。因为这二者有相当多的共同之处。大家一定认真阅读我写的 <strong>使用场景</strong> 的最后一点。</p>

      

      
        
    </div>
  </div>
  
</article>


  
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/helei112g" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2016 He Lei 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/Alex-fun/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/helei112g" class="mobile-nav-link">Github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'helei112g';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>